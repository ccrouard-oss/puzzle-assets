<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Puzzle 3D — Face à plat (auto-orientation robuste)</title>
  <style>
    html,body{height:100%;margin:0;background:#0d1117;color:#e6edf3;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    #app{position:fixed;inset:0}
    .hud{position:fixed;left:12px;top:12px;z-index:5;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.08);
      padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px);font-size:13px;display:flex;gap:10px;align-items:center}
    .btn{cursor:pointer;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.06);color:#e6edf3;
      padding:6px 10px;border-radius:8px;font-size:12px}
    .btn:hover{background:rgba(255,255,255,.12)}
    canvas{display:block; touch-action:none}
  </style>

  <script type="importmap">
  { "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  } }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <div><b>Puzzle 3D</b> — face à plat</div>
    <button id="faceBtn" class="btn" title="Recentrer (F)">Face</button>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // --- À adapter si besoin ---
    const MODEL_URL = 'puzzle_50_scattered.glb';

    // --- Scène / caméra (orthographique, pas de perspective) ---
    const app = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#0d1117');

    const camera = new THREE.OrthographicCamera(-1,1,1,-1,0.01,1000);
    camera.position.set(0,0,10);
    camera.up.set(0,1,0);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x334466, 0.9));
    const dir = new THREE.DirectionalLight(0xffffff, 0.5); dir.position.set(2,3,4); scene.add(dir);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enableRotate = false; // vue toujours à plat
    controls.enablePan = true;
    controls.enableZoom = true;

    // --- Utils ---
    function bboxOf(objects){
      const b = new THREE.Box3();
      for(const o of objects) b.expandByObject(o);
      return b;
    }
    function frameOrthoToBox(b){
      const size = new THREE.Vector3(); b.getSize(size);
      const center = b.getCenter(new THREE.Vector3());
      const pad = 1.10;
      const needW = size.x * pad, needH = size.y * pad;
      const a = window.innerWidth / window.innerHeight;
      let viewW, viewH;
      if (needW / needH > a){ viewW = needW/2; viewH = (needW/a)/2; }
      else { viewH = needH/2; viewW = (needH*a)/2; }
      camera.left = -viewW; camera.right = viewW;
      camera.top = viewH; camera.bottom = -viewH;
      camera.position.set(center.x, center.y, 10);
      camera.lookAt(center);
      camera.updateProjectionMatrix();
      controls.target.copy(center); controls.update();
    }

    // “Score face” (normales → caméra)
    const raycaster = new THREE.Raycaster();
    function frontScore(meshes){
      const b = bboxOf(meshes);
      const c = b.getCenter(new THREE.Vector3());
      const dir = new THREE.Vector3().subVectors(c, camera.position).normalize();
      raycaster.set(camera.position.clone(), dir);
      const hits = raycaster.intersectObjects(meshes, true);
      if(!hits.length) return -Infinity;
      let s = 0;
      const sample = hits.slice(0, 30);
      for(const h of sample){
        const nLocal = h.face?.normal?.clone() || new THREE.Vector3(0,0,1);
        const normalMatrix = new THREE.Matrix3().getNormalMatrix(h.object.matrixWorld);
        const nWorld = nLocal.applyMatrix3(normalMatrix).normalize();
        const toCam = new THREE.Vector3().subVectors(camera.position, h.point).normalize();
        s += nWorld.dot(toCam);
      }
      return s / sample.length;
    }

    // Aligne l’axe le plus petit (épaisseur) sur Z → face sur XY
    function alignThinAxisToZ(root, meshes){
      const b = bboxOf(meshes);
      const size = b.getSize(new THREE.Vector3());
      // détecter l’axe “épaisseur”
      const axes = [
        { axis:'x', v:size.x },
        { axis:'y', v:size.y },
        { axis:'z', v:size.z },
      ].sort((a,b)=>a.v-b.v);
      const thin = axes[0].axis;

      // remettre rotations
      root.rotation.set(0,0,0);
      root.updateMatrixWorld(true);

      // si épaisseur sur X → amener X sur Z (Ry ±90°)
      if(thin === 'x'){
        root.rotation.set(0, Math.PI/2, 0);
      }
      // si épaisseur sur Y → amener Y sur Z (Rx ∓90°)
      else if(thin === 'y'){
        root.rotation.set(-Math.PI/2, 0, 0);
      }
      // si déjà sur Z → rien

      root.updateMatrixWorld(true);

      // vérifie que les normales regardent la caméra (sinon flip Y)
      const s = frontScore(meshes);
      if(!(s>0)){
        root.rotateY(Math.PI);
        root.updateMatrixWorld(true);
      }
    }

    // --- Chargement GLB ---
    const loader = new GLTFLoader();
    let puzzleRoot = null;
    let meshes = [];
    let bboxAll = null;

    loader.load(MODEL_URL, (gltf)=>{
      puzzleRoot = gltf.scene;
      scene.add(puzzleRoot);

      // matières côté avant
      meshes = [];
      puzzleRoot.traverse(o=>{
        if(o.isMesh){
          meshes.push(o);
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          for(const m of mats){ if(m) m.side = THREE.FrontSide; }
        }
      });

      // recentrage XY sur origine (pratique pour cadrer)
      const b0 = bboxOf(meshes);
      const c0 = b0.getCenter(new THREE.Vector3());
      puzzleRoot.position.sub(new THREE.Vector3(c0.x, c0.y, 0));
      puzzleRoot.updateMatrixWorld(true);

      // === clé : orientation automatique sur XY ===
      alignThinAxisToZ(puzzleRoot, meshes);

      // cadre orthographique
      bboxAll = bboxOf(meshes);
      frameOrthoToBox(bboxAll);
    }, undefined, (e)=> console.error('Erreur GLB:', e));

    // UI recentrage
    document.getElementById('faceBtn').addEventListener('click', ()=>{
      if(bboxAll) frameOrthoToBox(bboxAll);
    });
    window.addEventListener('keydown', e => { if(e.key.toLowerCase()==='f') document.getElementById('faceBtn').click(); });

    // Resize + render
    function onResize(){
      renderer.setSize(window.innerWidth, window.innerHeight);
      if(bboxAll) frameOrthoToBox(bboxAll);
    }
    window.addEventListener('resize', onResize);

    (function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
