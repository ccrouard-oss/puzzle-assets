<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Puzzle – 2D strict (portrait 4:3)</title>
  <style>
    html,body{
      height:100%;
      margin:0;
      background:#0d1117;
      color:#e6edf3;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    }
    #app{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    }
    .hud{
      position:fixed; left:12px; top:12px; z-index:5;
      background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.08);
      padding:8px 10px; border-radius:10px; backdrop-filter:blur(6px);
      font-size:13px; line-height:1.35; display:flex; gap:10px; align-items:center
    }
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.1)}
    .btn{cursor:pointer;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.06);color:#e6edf3;padding:6px 10px;border-radius:8px;font-size:12px}
    canvas{display:block;margin:auto;touch-action:none;max-width:100%;max-height:100%}
  </style>

  <script type="importmap">
    { "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    } }
  </script>
</head>
<body>
  <div id="app"></div>

  <div class="hud">
    <div class="badge">Mode: 2D strict</div>
    <div class="badge" id="groupInfo">Bloc: 1 pièce</div>
    <div class="badge" id="placedInfo">0 placées</div>
    <label style="display:flex;gap:6px;align-items:center">
      <input type="checkbox" id="lockAfterMerge" checked /> Verrouiller blocs assemblés
    </label>
    <button class="btn" id="shuffleBtn">Mélanger</button>
  </div>

  <!-- Son : uniquement déclenché quand une pièce est posée à la bonne place -->
  <audio id="snapSound" src="https://ccrouard-oss.github.io/puzzle-assets/click.wav" preload="auto"></audio>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ========= CONFIG (portrait 4:3) ========================================
    const MODEL_URL = 'puzzle_50_scattered.glb';      // placé à côté de ce fichier
    const ROWS=5, COLS=10;
    const PUZZLE_W=3.0, PUZZLE_H=4.0;                 // 4:3 portrait (W < H)
    const CELL_W=PUZZLE_W/COLS, CELL_H=PUZZLE_H/ROWS;

    // Déplacement & aimantation
    const POS_EPS = 0.003;
    const LERP_DRAG = 0.10;
    const LERP_SNAP = 0.5;
    const SNAP_GRID = 0.18;
    const SNAP_NEIGH_EAGER = 0.14;
    const SNAP_NEIGH = 0.2;
    const STICKY_BAND = 0.25;

    // Distance min. pour éviter le chevauchement
    const MIN_CENTER_DIST = Math.min(CELL_W, CELL_H)*0.42;

    // Aire de jeu (autour du centre)
    const BOUNDS_MARGIN = 0.6;

    // ========= SCÈNE =========================================================
    const app = document.getElementById('app');
    const scene = new THREE.Scene(); scene.background = new THREE.Color('#0d1117');

    // --- Caméra orthographique "portrait" figée, centrée sur (0,0) ----------
    const PORTRAIT_MARGIN = 1.12; // marge autour du puzzle
    function setPortraitView(){
      const aspect = window.innerWidth / window.innerHeight; // ratio écran
      const targetW = PUZZLE_W * PORTRAIT_MARGIN;
      const targetH = PUZZLE_H * PORTRAIT_MARGIN;

      // On affiche au minimum le rectangle portrait targetW x targetH,
      // sans jamais forcer un cadre paysage.
      let viewW, viewH;
      if ((targetW / targetH) > aspect) {
        // écran plus "étroit" verticalement → étendre en hauteur
        viewW = targetW;
        viewH = targetW / aspect;
      } else {
        // écran plus "large" → étendre en largeur
        viewH = targetH;
        viewW = targetH * aspect;
      }

      camera.left = -viewW/2; camera.right = viewW/2;
      camera.top  =  viewH/2; camera.bottom = -viewH/2;
      camera.position.set(0,0,5);
      camera.lookAt(0,0,0);
      camera.updateProjectionMatrix();
    }

    function makeOrtho(){
      // Valeurs provisoires, setPortraitView fera le cadrage exact
      return new THREE.OrthographicCamera(-2, 2, 2, -2, -10, 10);
    }
    const camera = makeOrtho();

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    // Lumières
    scene.add(new THREE.HemisphereLight(0xffffff,0x223344,0.8));
    const dl = new THREE.DirectionalLight(0xffffff,0.6); dl.position.set(2,3,4); scene.add(dl);

    // Raycast & pointeur
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    // Racine puzzle
    const puzzleRoot = new THREE.Group(); scene.add(puzzleRoot);
    const pickableMeshes = [];
    const entriesByName = new Map();
    const entries = [];

    // Grille cible
    const x0 = -PUZZLE_W/2 + CELL_W/2;
    const y0 =  PUZZLE_H/2 - CELL_H/2;
    const targetOf = (rc)=> new THREE.Vector3(x0 + rc.c*CELL_W, y0 - rc.r*CELL_H, 0);

    // ========= UTILS =========================================================
    function forcePlanarZ(root, z=0){ root.traverse(o=>{ if(o.position) o.position.z = z; }); }
    function reparentKeepWorld(child, newParent){
      const wp = new THREE.Vector3(); child.getWorldPosition(wp);
      const wq = new THREE.Quaternion(); child.getWorldQuaternion(wq);
      newParent.add(child);
      child.position.copy(newParent.worldToLocal(wp));
      const inv = newParent.getWorldQuaternion(new THREE.Quaternion()).invert();
      child.quaternion.copy(inv.multiply(wq));
      child.scale.set(1,1,1);
    }

    // ========= CHARGEMENT GLB ===============================================
    const loader = new GLTFLoader();
    loader.load(MODEL_URL, (gltf)=>{
      const root = gltf.scene;
      root.traverse(o=>{
        if(o.isMesh){
          pickableMeshes.push(o);
          const mats = Array.isArray(o.material)? o.material : [o.material];
          for(const m of mats){ if(m){ m.side = THREE.FrontSide; } }
        }
      });
      orientFaceOn(root);

      for(const rNode of uniqueRootsUnder(root)){
        const rc = parseRC(rNode.name) || {r:0,c:0};
        const block = reparentAsBlock(rNode, puzzleRoot);
        const entry = { group:block, mesh:rNode, rc, target:targetOf(rc), placed:false, stickyTo:null };
        entries.push(entry);
        entriesByName.set(`r${rc.r}_c${rc.c}`, entry);
      }

      forcePlanarZ(puzzleRoot, 0);

      // Mélange initial : centré, sans chevauchement
      shufflePieces();
      setPortraitView();      // <<< verrouille le cadrage portrait
      updateHUD();
      render();
    }, undefined, err=>console.error(err));

    // ========= ORIENTATION / STRUCTURE GLB ==================================
    function orientFaceOn(root){
      root.rotation.set(0,0,0);
      root.updateMatrixWorld(true);
      const bbox = new THREE.Box3().setFromObject(root);
      if(bbox.getSize(new THREE.Vector3()).z > 0.2){
        root.rotation.x = Math.PI/2; // remet à plat si import "sur la tranche"
        root.updateMatrixWorld(true);
      }
    }
    function uniqueRootsUnder(root){
      const set = new Set();
      for(const m of pickableMeshes){
        let n=m; while(n.parent && n.parent!==root) n=n.parent;
        set.add(n);
      }
      return [...set];
    }
    function parseRC(name=''){
      const m = /r(\d+)_c(\d+)/i.exec(name);
      return m? {r:+m[1], c:+m[2]} : null;
    }
    function reparentAsBlock(node, parent){
      const block = new THREE.Group();
      parent.add(block);
      node.updateMatrixWorld(true);
      const wp = new THREE.Vector3(); node.getWorldPosition(wp);
      const wq = new THREE.Quaternion(); node.getWorldQuaternion(wq);
      block.position.copy(wp); block.quaternion.copy(wq); block.scale.set(1,1,1);
      block.add(node);
      node.position.set(0,0,0); node.quaternion.identity(); node.scale.set(1,1,1);
      return block;
    }

    // ========= DRAG/SNAP/COLLISION (2D) =====================================
    let dragging = null;
    let dragOffset = new THREE.Vector3();
    const dragPlane = new THREE.Plane(new THREE.Vector3(0,0,1), 0);

    function setPointer(e){
      const p = e.touches?.[0] || e.changedTouches?.[0] || e;
      const rect=renderer.domElement.getBoundingClientRect();
      pointer.x=((p.clientX-rect.left)/rect.width)*2-1;
      pointer.y=-((p.clientY-rect.top)/rect.height)*2+1;
      return p;
    }
    function rayFromPointer(){
      const r = new THREE.Ray();
      const origin = new THREE.Vector3(pointer.x, pointer.y, 0).unproject(camera);
      const dir = new THREE.Vector3(0,0,-1).transformDirection(camera.matrixWorld);
      r.origin.copy(origin); r.direction.copy(dir);
      return r;
    }
    function intersectPickable(){
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(pickableMeshes, true);
      for(const h of hits){
        const e = entryFromObject(h.object);
        if(e) return {entry:e, hitPoint:h.point};
      }
      return null;
    }
    function entryFromObject(obj){
      let n = obj;
      while(n && n.parent && n.parent!==puzzleRoot) n = n.parent;
      if(!n) return null;
      return entries.find(e=>e.group===n) || null;
    }
    function findBlock(g){
      let n=g; while(n.parent && n.parent!==puzzleRoot) n=n.parent;
      return n||g;
    }
    function clampInBounds(v){
      const halfW = PUZZLE_W/2 + BOUNDS_MARGIN;
      const halfH = PUZZLE_H/2 + BOUNDS_MARGIN;
      v.x = Math.max(-halfW, Math.min(halfW, v.x));
      v.y = Math.max(-halfH, Math.min(halfH, v.y));
      v.z = 0;
    }

    function neighRCs(rc){
      const list=[];
      if(rc.r>0)      list.push({r:rc.r-1,c:rc.c, dx:0,        dy:+CELL_H});
      if(rc.r<ROWS-1) list.push({r:rc.r+1,c:rc.c, dx:0,        dy:-CELL_H});
      if(rc.c>0)      list.push({r:rc.r,  c:rc.c-1, dx:-CELL_W,dy:0});
      if(rc.c<COLS-1) list.push({r:rc.r,  c:rc.c+1, dx:+CELL_W,dy:0});
      return list;
    }
    function isIntendedNeighbor(entry, other){
      const rc = entry.rc;
      return neighRCs(rc).some(n => `r${n.r}_c${n.c}` === `r${other.rc.r}_c${other.rc.c}`);
    }

    function resolveCollisionsFor(entry, ignoreForSnap=false){
      const A = findBlock(entry.group);
      const posA = A.position;
      for(const e of entries){
        const B = findBlock(e.group);
        if(B===A) continue;
        if(!ignoreForSnap && isIntendedNeighbor(entry, e)) continue;
        const posB = B.position;
        const delta = new THREE.Vector3().subVectors(posA, posB);
        const dist = delta.length();
        if(dist < MIN_CENTER_DIST){
          if(dist < 1e-6){
            delta.set(Math.random()-0.5, Math.random()-0.5, 0).normalize().multiplyScalar(MIN_CENTER_DIST);
          }else{
            delta.multiplyScalar((MIN_CENTER_DIST - dist)/dist);
          }
          posA.add(delta);
          clampInBounds(posA);
        }
      }
    }

    // Son "snap" uniquement quand une pièce est posée correctement
    const audioEl = document.getElementById('snapSound');
    function playSnap(){
      if(!audioEl) return;
      try{
        audioEl.currentTime = 0;
        const p = audioEl.play();
        if(p && typeof p.catch === 'function'){ p.catch(()=>{}); }
      }catch{}
    }

    function trySnapGrid(entry, final){
      const d = entry.group.position.distanceTo(entry.target);
      if(!final && d>SNAP_GRID) return false;

      const aim = entry.target.clone();
      if(final || d < SNAP_NEIGH_EAGER){ entry.group.position.copy(aim);}
      else { entry.group.position.lerp(aim, LERP_SNAP); }
      entry.group.position.z = 0;

      const ok = entry.group.position.distanceTo(aim) < (final? 2*POS_EPS : 0.02);
      if(ok){
        entry.group.position.copy(aim);
        entry.group.position.z = 0;
        entry.placed = true; entry.stickyTo = null;
        forcePlanarZ(findBlock(entry.group), 0);

        // ✅ Son uniquement en fin de pose correcte
        if (final) playSnap();

        updateHUD();
        return true;
      }
      return false;
    }

    function trySnapNeighbors(entry, final){
      const rc = entry.rc;
      const posA = entry.group.position;

      if(entry.stickyTo){
        const { nbKey, desired } = entry.stickyTo;
        const nb = entriesByName.get(nbKey);
        if(nb){
          const posB = nb.group.position;
          const dist = new THREE.Vector3().subVectors(posB, posA).sub(desired).length();
          if(dist < STICKY_BAND){
            const newPosA = new THREE.Vector3().subVectors(posB, desired);
            if(final || dist < SNAP_NEIGH_EAGER){ posA.copy(newPosA);} else { posA.lerp(newPosA, LERP_SNAP); }
            posA.z = 0;
            return true;
          } else {
            entry.stickyTo = null;
          }
        } else {
          entry.stickyTo = null;
        }
      }

      let best = null;
      for(const n of neighRCs(rc)){
        const nb = entriesByName.get(`r${n.r}_c${n.c}`);
        if(!nb) continue;

        const blockA = findBlock(entry.group);
        const blockB = findBlock(nb.group);
        if(blockA===blockB) continue;

        const posB = nb.group.position;
        const desired = new THREE.Vector3(n.dx, n.dy, 0);
        const dist = new THREE.Vector3().subVectors(posB, posA).sub(desired).length();
        if(best===null || dist < best.dist){ best = { nb, desired, dist, nbKey:`r${n.r}_c${n.c}` }; }
      }
      if(!best) return false;

      const eager = best.dist < SNAP_NEIGH_EAGER;
      const near  = best.dist < (final? 2*POS_EPS : SNAP_NEIGH);
      if(eager || near){
        const blockA = findBlock(entry.group);
        const blockB = findBlock(best.nb.group);
        const newPosA = new THREE.Vector3().subVectors(best.nb.group.position, best.desired);
        if(eager || final){ posA.copy(newPosA);} else { posA.lerp(newPosA, LERP_SNAP); }
        posA.z = 0;

        mergeBlocks(blockA, blockB);
        forcePlanarZ(findBlock(entry.group), 0);
        entry.stickyTo = { nbKey: best.nbKey, desired: best.desired.clone() };
        updateHUD();
        return true;
      }
      return false;
    }

    function mergeBlocks(A, B){
      if(A===B) return;
      const parent = new THREE.Group(); puzzleRoot.add(parent);
      const pa = new THREE.Vector3(); A.getWorldPosition(pa);
      const pb = new THREE.Vector3(); B.getWorldPosition(pb);
      parent.position.copy(pa.add(pb).multiplyScalar(0.5));
      reparentKeepWorld(A, parent);
      reparentKeepWorld(B, parent);
      forcePlanarZ(parent, 0);
      parent.userData.locked = document.getElementById('lockAfterMerge').checked;

      for(const e of entries){
        const r = findBlock(e.group);
        if(r===A || r===B || r===parent){ e.group = parent; e.placed = true; }
      }
    }

    // ========= MÉLANGE CENTRÉ SANS CHEVAUCHEMENT ============================
    function shufflePieces(){
      const N = entries.length;
      const cols = Math.ceil(Math.sqrt(N));
      const rows = Math.ceil(N / cols);

      const sx = CELL_W * 1.15;
      const sy = CELL_H * 1.15;

      const startX = -((cols - 1) * sx) / 2;
      const startY =  ((rows - 1) * sy) / 2;

      let i = 0;
      for (const e of entries){
        const r = Math.floor(i / cols);
        const c = i % cols;

        const jx = (Math.random() - 0.5) * CELL_W * 0.2;
        const jy = (Math.random() - 0.5) * CELL_H * 0.2;

        e.group.position.set(startX + c * sx + jx, startY - r * sy + jy, 0);
        e.placed = false; e.stickyTo = null;
        i++;
      }
      forcePlanarZ(puzzleRoot, 0);
    }

// ========= INPUTS / RENDER ==============================================

// (déclarations déjà faites plus haut, on ne les répète pas)

function pointerDown(e){
  e.preventDefault();
  setPointer(e);
  const pick = intersectPickable();
  if(!pick) return;
  const { entry, hitPoint } = pick;
  const root = findBlock(entry.group);
  if(root.userData.locked) return;
  dragging = entry;
  const center = root.position.clone();
  dragOffset.copy(hitPoint.clone().sub(center));
  dragOffset.z = 0;
}

function pointerMove(e){
  if(!dragging) return;
  e.preventDefault();
  setPointer(e);
  const ray = rayFromPointer();
  const hit = new THREE.Vector3();
  if(!ray.intersectPlane(dragPlane, hit)) return;

  const pos = dragging.group.position;
  const target = hit.sub(dragOffset);
  pos.lerp(target, LERP_DRAG);
  clampInBounds(pos);

  if(trySnapNeighbors(dragging, false)) return;
  if(trySnapGrid(dragging, false)) return;

  resolveCollisionsFor(dragging, false);
}

function pointerUp(e){
  if(!dragging) return;
  e.preventDefault();
  if(!trySnapNeighbors(dragging, true)) trySnapGrid(dragging, true);
  dragging = null;
}

const placedInfo = document.getElementById('placedInfo');
const groupInfo  = document.getElementById('groupInfo');

function updateHUD(){
  const nPlaced = entries.filter(e=>e.placed).length;
  placedInfo.textContent = `${nPlaced} placées`;
  const blk = dragging? findBlock(dragging.group) : null;
  const count = blk? countPieces(blk):1;
  groupInfo.textContent = `Bloc: ${count} pièce${count>1?'s':''}`;
}

function countPieces(block){
  let c=0; for(const e of entries){ if(findBlock(e.group)===findBlock(block)) c++; }
  return c||1;
}

function render(){ requestAnimationFrame(render); updateHUD(); renderer.render(scene, camera); }

window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  setPortraitView();
});

document.getElementById('shuffleBtn').addEventListener('click', ()=>{
  shufflePieces();
  updateHUD();
});

renderer.domElement.addEventListener('pointerdown', pointerDown, {passive:false});
renderer.domElement.addEventListener('pointermove', pointerMove, {passive:false});
window.addEventListener('pointerup', pointerUp, {passive:false});

  </script>
</body>
</html>
