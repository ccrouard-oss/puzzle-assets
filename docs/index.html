<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Puzzle 3D ‚Äì Protect the Oceans</title>
<style>
  html,body {margin:0;height:100%;background:#0f172a;color:#e5e7eb;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  #app {position:fixed; inset:0}
  #hud {position:fixed; left:16px; top:12px; z-index:10; background:rgba(0,0,0,.35); padding:8px 10px; border-radius:8px; font-size:14px}
  #win {position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.6); font-weight:600; font-size:20px}
  canvas {display:block; width:100%; height:100%}
  .kbd {padding:1px 6px; border:1px solid #94a3b8; border-radius:6px; font-size:12px}
</style>

<!-- Import map : Three.js r160 + addons -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="app"></div>
<div id="hud">üß© D√©placez les pi√®ces (clic + glisser) ‚Ä¢ Zoom molette ‚Ä¢ <span class="kbd">R</span> r√©initialiser cam√©ra</div>
<div id="win">üéâ Puzzle compl√©t√© !</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

const ROWS=5, COLS=10, BOARD_W=3.0, BOARD_H=4.0;
const SNAP_DIST=0.12, SNAP_MS=180, WIN_EPS=0.01;

// --- sc√®ne ---
const host = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
host.appendChild(renderer.domElement);         // <-- on ajoute d'abord le canvas

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0f172a);

const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 100); // aspect mis √† jour dans resize()
camera.position.set(0,0,6);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.enablePan = false; controls.target.set(0,0,0);

scene.add(new THREE.AmbientLight(0xffffff,0.9));
const dir = new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(1,1,2); scene.add(dir);

// utilitaires
const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
const dragPlane = new THREE.Plane(new THREE.Vector3(0,0,1),0); const hitPoint = new THREE.Vector3();
function ndc(ev){const r=renderer.domElement.getBoundingClientRect(); mouse.x=((ev.clientX-r.left)/r.width)*2-1; mouse.y=-((ev.clientY-r.top)/r.height)*2+1;}
function step(){return {dx:BOARD_W/COLS, dy:BOARD_H/ROWS};}
function home(r,c){const s=step(); const x0=-BOARD_W/2+c*s.dx, y0=-BOARD_H/2+r*s.dy; return new THREE.Vector3(x0+s.dx*0.5, y0+s.dy*0.5, 0);}
function rc(name){const m=name.match(/Piece_(\d+)_(\d+)/); return m?{r:+m[1],c:+m[2]}:{r:0,c:0};}

// charge le GLB plac√© DANS /docs (m√™me dossier)
const loader = new GLTFLoader(); const pieces = [];
loader.load('./puzzle_50_scattered.glb', (gltf)=>{
  scene.add(gltf.scene);
  gltf.scene.traverse(o=>{
    if(o.isMesh && /^Piece_\d+_\d+/.test(o.name)){
      const {r,c}=rc(o.name);
      o.userData.r=r; o.userData.c=c;
      o.userData.home=home(r,c);
      o.userData.homeQuat=new THREE.Quaternion();
      pieces.push(o);
    }
  });
  console.log('‚úÖ Pi√®ces d√©tect√©es :', pieces.length);
}, undefined, err=>console.error('‚ùå Erreur GLB :', err));

// drag & snap
let dragging=null, dragOffset=new THREE.Vector3();
renderer.domElement.addEventListener('pointerdown', onDown);
renderer.domElement.addEventListener('pointermove', onMove);
renderer.domElement.addEventListener('pointerup', onUp);
window.addEventListener('resize', resize);
window.addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='r'){camera.position.set(0,0,6); controls.target.set(0,0,0);} });

function pick(){raycaster.setFromCamera(mouse,camera); const h=raycaster.intersectObjects(pieces,false); return h.length?h[0]:null;}
function onDown(ev){ndc(ev); const hit=pick(); if(!hit) return; dragging=hit.object; dragging.renderOrder=999; raycaster.ray.intersectPlane(dragPlane, hitPoint); dragOffset.copy(hitPoint).sub(dragging.position);}
function onMove(ev){if(!dragging) return; ndc(ev); raycaster.ray.intersectPlane(dragPlane, hitPoint); const p=hitPoint.clone().sub(dragOffset); p.z=0.02; dragging.position.copy(p);}
function tweenTo(obj, target, ms){const a=obj.position.clone(); const t0=performance.now(); function step(now){const u=Math.min(1,(now-t0)/ms); obj.position.lerpVectors(a,target,1-(1-u)*(1-u)); if(u<1) requestAnimationFrame(step); else checkWin();} requestAnimationFrame(step);}
function onUp(){if(!dragging) return; const d=dragging.position.distanceTo(dragging.userData.home); if(d<=SNAP_DIST){tweenTo(dragging, dragging.userData.home, SNAP_MS);} else { for(const p of pieces){ if(p===dragging) continue; const near=p.position.distanceTo(dragging.position)<=SNAP_DIST; const ok=p.position.distanceTo(p.userData.home)<=WIN_EPS; if(near&&ok){tweenTo(dragging, dragging.userData.home, SNAP_MS); break; } } } dragging.renderOrder=0; dragging=null;}
function checkWin(){const ok=pieces.length>0 && pieces.every(p=>p.position.distanceTo(p.userData.home)<=WIN_EPS && Math.abs(1-p.quaternion.dot(p.userData.homeQuat))<1e-3); if(ok) document.getElementById('win').style.display='flex';}

// resize apr√®s cr√©ation de la cam√©ra (fix de l‚Äôerreur)
function resize(){
  const w = host.clientWidth, h = host.clientHeight;
  renderer.setSize(w,h);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
}
resize(); // <-- appel√© ici, maintenant que camera existe

(function loop(){requestAnimationFrame(loop); controls.update(); renderer.render(scene,camera);})();
</script>
</body>
</html>
