<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Puzzle – 2D strict ➜ 3D limitée</title>
  <style>
    html,body{height:100%;margin:0;background:#0d1117;color:#e6edf3;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    #app{position:fixed;inset:0}
    .hud{position:fixed;left:12px;top:12px;z-index:5;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.08);
      padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px);font-size:13px;line-height:1.35;display:flex;gap:10px;align-items:center}
    .btn{cursor:pointer;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.06);color:#e6edf3;padding:6px 10px;border-radius:8px;font-size:12px}
    .btn:hover{background:rgba(255,255,255,.12)}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.1)}
    canvas{display:block;touch-action:none}
  </style>
  <script type="importmap">
    { "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    } }
  </script>
</head>
<body>
  <div id="app"></div>

  <div class="hud">
    <div class="badge" id="mode">Mode: 2D</div>
    <button id="startBtn" class="btn" title="Activer 3D limitée">Démarrer (3D)</button>
    <button id="faceBtn" class="btn" title="Revenir face 2D (F)">Face</button>
    <div class="badge" id="groupInfo">Bloc: 1 pièce</div>
    <div class="badge" id="placedInfo">0 placées</div>
  </div>

  <audio id="snapSound" src="click.wav" preload="auto"></audio>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ========= CONFIGS INVARIABLES (4:3 PORTRAIT, 2D PAR DÉFAUT) ============
    const MODEL_URL = 'puzzle_50_scattered.glb';     // adapte si nécessaire
    const ROWS=5, COLS=10;
    const PUZZLE_W=3.0, PUZZLE_H=4.0;                // 4:3 portrait
    const CELL_W=PUZZLE_W/COLS, CELL_H=PUZZLE_H/ROWS;

    // Magnétisme (plus ferme)
    const SNAP_GRID = 0.18;      // rayon de capture sur la grille (position cible)
    const SNAP_NEIGH = 0.16;     // rayon de capture voisinage (delta attendu)
    const POS_EPS = 0.003;
    const LERP_DRAG = 0.6, LERP_SNAP = 0.45;

    // Profondeur limitée
    const Z_LIMIT_2D = 0.0;      // 2D stricte
    const Z_LIMIT_3D = 0.02;     // ±2 cm en “unités puzzle” (très faible)
    const CAMERA_TILT_DEG = 6;   // léger tilt max en 3D

    // Déplacements bornés dans une marge autour du puzzle pour éviter de “perdre” des pièces
    const BOUNDS_MARGIN = 0.6;

    // ========= MISE EN PLACE SCÈNE ==========================================
    const app = document.getElementById('app');
    const scene = new THREE.Scene(); scene.background = new THREE.Color('#0d1117');

    // Caméra ORTHO pour le mode 2D (face-on garanti)
    let is3D = false;
    const ortho = makeOrtho();
    function makeOrtho(){
      const aspect = window.innerWidth / window.innerHeight;
      // On cadre le puzzle portrait (4 de haut) avec marges
      const viewH = PUZZLE_H * 1.15;
      const viewW = viewH * aspect;
      return new THREE.OrthographicCamera(-viewW/2, viewW/2, viewH/2, -viewH/2, -10, 10);
    }

    // Caméra perspective pour le mode 3D léger
    const persp = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.01, 20);
    persp.position.set(0,0,6);

    // Caméra active = ORTHO au départ
    let camera = ortho;

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    // Lumières douces
    scene.add(new THREE.HemisphereLight(0xffffff,0x223344,0.8));
    const dl = new THREE.DirectionalLight(0xffffff,0.6); dl.position.set(2,3,4); scene.add(dl);

    // Contrôles : pas de rotation en 2D ; rotation TRÈS LIMITÉE en 3D
    const controls = new OrbitControls(persp, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.08;
    controls.enableRotate = false; // sera activé au passage 3D
    controls.enablePan = true;
    controls.enableZoom = true;
    controls.minDistance = 4.5;     // bornes zoom
    controls.maxDistance = 8.0;

    // Limiter l’angle pour rester quasi face-on
    const tilt = THREE.MathUtils.degToRad(CAMERA_TILT_DEG);
    controls.minPolarAngle = Math.PI/2 - tilt;  // ~ face
    controls.maxPolarAngle = Math.PI/2 + tilt;

    // Raycast & utilitaires
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const tmpV3 = new THREE.Vector3();
    const dragOffsetLocal = new THREE.Vector3();

    // Puzzle
    const puzzleRoot = new THREE.Group(); scene.add(puzzleRoot);
    const pickableMeshes = [];
    const entriesByName = new Map();
    const entries = [];

    // Cibles (grille)
    const x0 = -PUZZLE_W/2 + CELL_W/2;
    const y0 =  PUZZLE_H/2 - CELL_H/2;
    const targetOf = (rc)=> new THREE.Vector3(x0 + rc.c*CELL_W, y0 - rc.r*CELL_H, 0);

    // ======== CHARGEMENT GLB & NORMALISATION FACE ============================
    const loader = new GLTFLoader();
    loader.load(MODEL_URL, (gltf)=>{
      const root = gltf.scene;
      root.traverse(o=>{
        if(o.isMesh){
          pickableMeshes.push(o);
          const mats = Array.isArray(o.material)? o.material : [o.material];
          for(const m of mats){ if(m){ m.side = THREE.FrontSide; } }
        }
      });

      // Corriger si « sur la tranche » : on force la face visible en Z+
      orientFaceOn(root);

      // Chaque pièce => bloc indépendant (enfant direct de puzzleRoot)
      const pieceRoots = uniqueRootsUnder(root);
      for(const rNode of pieceRoots){
        const rc = parseRC(rNode.name) || {r:0,c:0};
        const block = reparentAsBlock(rNode, puzzleRoot);
        const entry = { group:block, mesh:rNode, rc, target:targetOf(rc), placed:false };
        entries.push(entry);
        entriesByName.set(`r${rc.r}_c${rc.c}`, entry);
      }

      // 2D stricte à l’état initial
      forcePlanarZ(puzzleRoot, 0);
      updateHUD();
      frame2D();
    }, undefined, err=>console.error(err));

    function orientFaceOn(root){
      // On aligne la face du puzzle vers +Z (pour éviter la tranche)
      root.updateMatrixWorld(true);
      // Heuristique simple : calcule la bbox et “aplatit” les rotations X/Y
      root.rotation.set(0,0,0);
      root.updateMatrixWorld(true);
      // Si nécessaire, retourne 180° X ou Y (selon les cas de GLB)
      // (On essaye X puis Y pour éviter un verso visible)
      const bbox = new THREE.Box3().setFromObject(root);
      if(bbox.getSize(new THREE.Vector3()).z > 0.2){ // puzzle trop épais => probable rotation erronée
        root.rotation.x = Math.PI/2;
        root.updateMatrixWorld(true);
      }
    }

    function uniqueRootsUnder(root){
      const set = new Set();
      for(const m of pickableMeshes){
        let n=m; while(n.parent && n.parent!==root) n=n.parent;
        set.add(n);
      }
      return [...set];
    }

    function parseRC(name=''){
      const m = /r(\d+)_c(\d+)/i.exec(name);
      return m? {r:+m[1], c:+m[2]} : null;
    }

    function reparentAsBlock(node, parent){
      const block = new THREE.Group();
      parent.add(block);
      node.updateMatrixWorld(true);

      // Récupérer transform monde de node, puis reparent
      const wp = new THREE.Vector3(); node.getWorldPosition(wp);
      const wq = new THREE.Quaternion(); node.getWorldQuaternion(wq);

      block.position.copy(wp);
      block.quaternion.copy(wq);
      block.scale.set(1,1,1);

      block.add(node);
      node.position.set(0,0,0);
      node.quaternion.identity();
      node.scale.set(1,1,1);
      return block;
    }

    // ======== DRAG PLAN (z=0), LIMITES & MAGNÉTISME ==========================
    let dragging = null;
    let dragPlane = new THREE.Plane(new THREE.Vector3(0,0,1), 0); // plan z=0
    let dragStartPos = new THREE.Vector3();

    function setPointer(e){
      const p = e.touches?.[0] || e.changedTouches?.[0] || e;
      const rect=renderer.domElement.getBoundingClientRect();
      pointer.x=((p.clientX-rect.left)/rect.width)*2-1;
      pointer.y=-((p.clientY-rect.top)/rect.height)*2+1;
      return p;
    }

    function intersectPickable(){
      (camera.isOrthographicCamera? raycaster.setFromCamera(pointer, camera) : raycaster.setFromCamera(pointer, persp));
      const hits = raycaster.intersectObjects(pickableMeshes, true);
      for(const h of hits){
        const e = entryFromObject(h.object);
        if(e) return e;
      }
      return null;
    }

    function entryFromObject(obj){
      let n = obj;
      while(n && n.parent && n.parent!==puzzleRoot) n = n.parent;
      if(!n) return null;
      return entries.find(e=>e.group===n) || null;
    }

    function pointerDown(e){
      e.preventDefault();
      setPointer(e);
      const entry = intersectPickable();
      if(!entry) return;

      dragging = entry;
      dragStartPos.copy(entry.group.position);
      controls.enabled = false;

      // plan z=0 (2D), et même en 3D on reste quasi-plan
      dragPlane.set(new THREE.Vector3(0,0,1), 0);
    }

    function pointerMove(e){
      if(!dragging) return;
      e.preventDefault();
      const p = setPointer(e);

      // Ray ⇢ plan z=0
      const ray = rayFromPointer();
      const hit = new THREE.Vector3();
      if(!ray.intersectPlane(dragPlane, hit)) return;

      // Lerp pour douceur
      dragging.group.position.lerp(hit, LERP_DRAG);

      // Clamp XY dans une boîte entourant le puzzle
      clampInBounds(dragging.group.position);

      // Z strictement limité
      dragging.group.position.z = clampZ(is3D? Z_LIMIT_3D : Z_LIMIT_2D, dragging.group.position.z);

      // Magnétisme temps réel (voisinage prioritaire puis grille)
      trySnapNeighbors(dragging, false) || trySnapGrid(dragging, false);
    }

    function pointerUp(e){
      if(!dragging) return;
      e.preventDefault();

      // Dernière tentative de snap ferme
      if(!trySnapNeighbors(dragging, true)) trySnapGrid(dragging, true);

      dragging = null;
      controls.enabled = is3D; // re-enable si 3D
    }

    function rayFromPointer(){
      const r = new THREE.Ray();
      if(camera.isOrthographicCamera){
        // En ortho, le rayon est perpendiculaire à l’écran
        const origin = new THREE.Vector3(pointer.x, pointer.y, 0)
          .unproject(ortho);
        const dir = new THREE.Vector3(0,0,-1).transformDirection(ortho.matrixWorld);
        r.origin.copy(origin);
        r.direction.copy(dir);
      }else{
        raycaster.setFromCamera(pointer, persp);
        r.copy(raycaster.ray);
      }
      return r;
    }

    function clampZ(limit, z){
      return Math.max(-limit, Math.min(limit, z));
    }

    function clampInBounds(v){
      const halfW = PUZZLE_W/2 + BOUNDS_MARGIN;
      const halfH = PUZZLE_H/2 + BOUNDS_MARGIN;
      v.x = Math.max(-halfW, Math.min(halfW, v.x));
      v.y = Math.max(-halfH, Math.min(halfH, v.y));
    }

    function forcePlanarZ(root, z=0){
      root.traverse(o=>{ if(o.position) o.position.z = z; });
    }

    // ======== SNAP GRILLE & VOISINAGE (avec fusion bloc↔bloc) ================
    const audioEl = document.getElementById('snapSound');
    function playSnap(){ try{ audioEl.currentTime=0; audioEl.play().catch(()=>{});}catch{} }

    function trySnapGrid(entry, final){
      const d = entry.group.position.distanceTo(entry.target);
      if(!final && d>SNAP_GRID) return false;

      const aim = entry.target.clone();
      entry.group.position.lerp(aim, LERP_SNAP);
      entry.group.position.z = clampZ(is3D? Z_LIMIT_3D : Z_LIMIT_2D, 0);

      const ok = entry.group.position.distanceTo(aim) < (final? 2*POS_EPS : 0.02);
      if(ok){
        entry.group.position.copy(aim);
        entry.group.position.z = clampZ(is3D? Z_LIMIT_3D : Z_LIMIT_2D, 0);
        entry.placed = true;
        forcePlanarZ(findBlock(entry.group), 0);
        playSnap(); updateHUD();
        return true;
      }
      return false;
    }

    function neighRCs(rc){
      const list=[];
      if(rc.r>0)      list.push({r:rc.r-1,c:rc.c, dx:0,        dy:+CELL_H});
      if(rc.r<ROWS-1) list.push({r:rc.r+1,c:rc.c, dx:0,        dy:-CELL_H});
      if(rc.c>0)      list.push({r:rc.r,  c:rc.c-1, dx:-CELL_W,dy:0});
      if(rc.c<COLS-1) list.push({r:rc.r,  c:rc.c+1, dx:+CELL_W,dy:0});
      return list;
    }

    function trySnapNeighbors(entry, final){
      const posA = entry.group.position;
      const rc = entry.rc;
      for(const n of neighRCs(rc)){
        const key = `r${n.r}_c${n.c}`;
        const nb = entriesByName.get(key); if(!nb) continue;

        // déjà dans le même bloc ?
        if(findBlock(entry.group) === findBlock(nb.group)) continue;

        const posB = nb.group.position;
        const desired = new THREE.Vector3(n.dx, n.dy, 0);
        const current = new THREE.Vector3().subVectors(posB, posA);
        const gap = current.clone().sub(desired);
        const dist = gap.length();

        if(dist < (final? 2*POS_EPS : SNAP_NEIGH)){
          const newPosA = new THREE.Vector3().subVectors(posB, desired);
          entry.group.position.lerp(newPosA, LERP_SNAP);
          entry.group.position.z = clampZ(is3D? Z_LIMIT_3D : Z_LIMIT_2D, 0);

          const ok = entry.group.position.distanceTo(newPosA) < (final? 2*POS_EPS : 0.02);
          if(ok){
            entry.group.position.copy(newPosA);
            entry.group.position.z = clampZ(is3D? Z_LIMIT_3D : Z_LIMIT_2D, 0);
            mergeBlocks(entry.group, nb.group);
            forcePlanarZ(findBlock(entry.group), 0);
            playSnap(); updateHUD();
            return true;
          }
        }
      }
      return false;
    }

    function findBlock(g){
      let n=g; while(n.parent && n.parent!==puzzleRoot) n=n.parent;
      return n||g;
    }

    function mergeBlocks(a, b){
      const A = findBlock(a), B = findBlock(b);
      if(A===B) return;
      const parent = new THREE.Group(); puzzleRoot.add(parent);

      // placer parent au barycentre
      const pa = new THREE.Vector3(); A.getWorldPosition(pa);
      const pb = new THREE.Vector3(); B.getWorldPosition(pb);
      parent.position.copy(pa.add(pb).multiplyScalar(0.5));

      reparentKeepWorld(A, parent);
      reparentKeepWorld(B, parent);

      // Tout à z=0 (coplanaire)
      forcePlanarZ(parent, 0);

      // Mettre à jour les entries pour pointer sur le nouveau bloc
      for(const e of entries){
        if(findBlock(e.group)===A || findBlock(e.group)===B || findBlock(e.group)===parent){
          e.group = parent;
        }
      }
    }

    function reparentKeepWorld(child, newParent){
      const wp = new THREE.Vector3(); child.getWorldPosition(wp);
      const wq = new THREE.Quaternion(); child.getWorldQuaternion(wq);
      newParent.add(child);
      child.position.copy(newParent.worldToLocal(wp));
      const inv = newParent.getWorldQuaternion(new THREE.Quaternion()).invert();
      child.quaternion.copy(inv.multiply(wq));
      child.scale.set(1,1,1);
    }

    // ======== HUD & CAMÉRAS ==================================================
    const placedInfo = document.getElementById('placedInfo');
    const groupInfo  = document.getElementById('groupInfo');
    const modeInfo   = document.getElementById('mode');

    function updateHUD(){
      const nPlaced = entries.filter(e=>e.placed).length;
      placedInfo.textContent = `${nPlaced} placées`;

      // Taille du bloc sélectionné (si dragging)
      const blk = dragging? findBlock(dragging.group) : null;
      groupInfo.textContent = `Bloc: ${blk? countPieces(blk):1} pièce${(blk&&countPieces(blk)>1)?'s':''}`;
    }

    function countPieces(block){
      let c=0;
      for(const e of entries){ if(findBlock(e.group)===findBlock(block)) c++; }
      return c||1;
    }

    function frame2D(){
      camera = ortho;
      modeInfo.textContent = 'Mode: 2D';
      // centrer le puzzle
      ortho.position.set(0,0,5);
      ortho.lookAt(0,0,0);
      forcePlanarZ(puzzleRoot, 0);
    }

    function frame3D(){
      camera = persp;
      modeInfo.textContent = 'Mode: 3D limité';
      // léger tilt initial
      puzzleRoot.rotation.set(THREE.MathUtils.degToRad(4), THREE.MathUtils.degToRad(-3), 0);
      controls.update();
    }

    // ======== RENDER LOOP & EVENTS ===========================================
    function render(){ requestAnimationFrame(render); if(is3D) controls.update(); renderer.render(scene, camera); }
    render();

    window.addEventListener('resize', ()=>{
      // maj ORTHO
      const aspect = window.innerWidth / window.innerHeight;
      const viewH = PUZZLE_H * 1.15;
      const viewW = viewH * aspect;
      ortho.left = -viewW/2; ortho.right = viewW/2; ortho.top = viewH/2; ortho.bottom = -viewH/2;
      ortho.updateProjectionMatrix();

      // maj PERSPECTIVE
      persp.aspect = aspect; persp.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function onKeyDown(e){ if(e.key.toLowerCase()==='f'){ is3D=false; controls.enableRotate=false; frame2D(); } }
    window.addEventListener('keydown', onKeyDown);

    // Pointeurs
    renderer.domElement.addEventListener('pointerdown', pointerDown, {passive:false});
    window.addEventListener('pointermove', pointerMove, {passive:false});
    window.addEventListener('pointerup',   pointerUp,   {passive:false});
    renderer.domElement.addEventListener('touchstart',  pointerDown, {passive:false});
    window.addEventListener('touchmove',   pointerMove, {passive:false});
    window.addEventListener('touchend',    pointerUp,   {passive:false});

    // Boutons
    document.getElementById('startBtn').addEventListener('click', ()=>{
      is3D = true;
      controls.enableRotate = true; controls.enabled = true;
      frame3D();
    });
    document.getElementById('faceBtn').addEventListener('click', ()=>{
      is3D = false; controls.enableRotate=false; frame2D();
    });
  </script>
</body>
</html>
