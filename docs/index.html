<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Puzzle 3D — Respect strict du format portrait</title>
  <style>
    html,body{height:100%;margin:0;background:#0d1117;color:#e6edf3;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    #app{position:fixed;inset:0}
    .hud{position:fixed;left:12px;top:12px;z-index:5;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.08);
      padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px);font-size:13px;display:flex;gap:10px;align-items:center}
    .btn{cursor:pointer;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.06);color:#e6edf3;
      padding:6px 10px;border-radius:8px;font-size:12px}
    .btn:hover{background:rgba(255,255,255,.12)}
    canvas{display:block; touch-action:none}
  </style>
  <script type="importmap">
  { "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  } }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <div><b>Puzzle 3D</b> — format image respecté</div>
    <button id="faceBtn" class="btn" title="Recentrer (F)">Face</button>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // === Paramètres ===
    const MODEL_URL = 'puzzle_50_scattered.glb';
    const DO_ROTATE_180 = false; // passe à true si tu veux retourner de 180° dans le plan

    // === Scène / Caméra (orthographique, vue à plat) ===
    const app = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#0d1117');

    const camera = new THREE.OrthographicCamera(-1,1,1,-1,0.01,1000);
    camera.position.set(0,0,10);
    camera.up.set(0,1,0);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x334466, 0.9));
    const dir = new THREE.DirectionalLight(0xffffff, 0.5); dir.position.set(2,3,4); scene.add(dir);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enableRotate = false; // on reste à plat
    controls.enablePan = true;
    controls.enableZoom = true;

    // === Utils ===
    function bboxOf(objects){
      const b = new THREE.Box3();
      for(const o of objects) b.expandByObject(o);
      return b;
    }
    function frameOrthoToBox(b){
      const size = new THREE.Vector3(); b.getSize(size);
      const center = b.getCenter(new THREE.Vector3());
      const pad = 1.10;
      const needW = size.x * pad, needH = size.y * pad;
      const a = window.innerWidth / window.innerHeight;
      let viewW, viewH;
      if (needW / needH > a){ viewW = needW/2; viewH = (needW/a)/2; }
      else { viewH = needH/2; viewW = (needH*a)/2; }
      camera.left = -viewW; camera.right = viewW;
      camera.top = viewH; camera.bottom = -viewH;
      camera.position.set(center.x, center.y, 10);
      camera.lookAt(center);
      camera.updateProjectionMatrix();
      controls.target.copy(center); controls.update();
    }

    // Aligne l’axe le plus fin (épaisseur) sur Z → plan XY
    function alignThinAxisToZ(root, meshes){
      const b = bboxOf(meshes);
      const s = b.getSize(new THREE.Vector3());
      const axes = [{a:'x',v:s.x},{a:'y',v:s.y},{a:'z',v:s.z}].sort((A,B)=>A.v-B.v);
      const thin = axes[0].a;
      root.rotation.set(0,0,0);
      if(thin==='x') root.rotation.set(0, Math.PI/2, 0);
      else if(thin==='y') root.rotation.set(-Math.PI/2, 0, 0);
      root.updateMatrixWorld(true);
    }

    // Lit le ratio réel de la texture d’origine (si intégrée dans le GLB)
    function getTextureAspect(meshes){
      for(const m of meshes){
        const matArr = Array.isArray(m.material) ? m.material : [m.material];
        for(const mat of matArr){
          if(mat && mat.map && mat.map.image){
            const img = mat.map.image;
            const w = img.naturalWidth || img.videoWidth || img.width;
            const h = img.naturalHeight || img.videoHeight || img.height;
            if(w && h) return w / h; // >1 paysage, <1 portrait
          }
        }
      }
      return null; // inconnu
    }

    // Fait correspondre l’orientation XY du modèle au ratio texture (portrait/paysage)
    function enforceOrientationToTexture(root, meshes){
      const texAr = getTextureAspect(meshes);
      const b = bboxOf(meshes);
      const sx = b.getSize(new THREE.Vector3()).x;
      const sy = b.getSize(new THREE.Vector3()).y;

      if(texAr){ // si connu
        const textureIsPortrait = texAr < 1.0;
        const modelIsLandscape = sx > sy;
        const modelIsPortrait  = sy >= sx;

        if(textureIsPortrait && modelIsLandscape){
          // on met le modèle en portrait pour coller à l’image source
          root.rotateZ(Math.PI/2);
        } else if(!textureIsPortrait && modelIsPortrait){
          // image source paysage, modèle portrait → corrige
          root.rotateZ(-Math.PI/2);
        }
        root.updateMatrixWorld(true);
      } else {
        // fallback léger : si le modèle est paysage, on le met en portrait
        if(sx > sy){ root.rotateZ(Math.PI/2); root.updateMatrixWorld(true); }
      }
    }

    // === Chargement GLB ===
    const loader = new GLTFLoader();
    let puzzleRoot = null;
    let meshes = [];
    let bboxAll = null;

    loader.load(MODEL_URL, (gltf)=>{
      puzzleRoot = gltf.scene;
      scene.add(puzzleRoot);

      meshes=[];
      puzzleRoot.traverse(o=>{
        if(o.isMesh){
          meshes.push(o);
          const arr = Array.isArray(o.material)?o.material:[o.material];
          for(const m of arr){ if(m) m.side = THREE.FrontSide; }
        }
      });

      // recentre XY à l’origine
      const b0 = bboxOf(meshes);
      const c0 = b0.getCenter(new THREE.Vector3());
      puzzleRoot.position.sub(new THREE.Vector3(c0.x, c0.y, 0));
      puzzleRoot.updateMatrixWorld(true);

      // 1) place l’épaisseur sur Z (plan XY)
      alignThinAxisToZ(puzzleRoot, meshes);

      // 2) respecte le format d’origine de l’image (portrait/paysage) via la texture
      enforceOrientationToTexture(puzzleRoot, meshes);

      // 3) optionnel : rotation plane 180° si demandé
      if(DO_ROTATE_180){
        puzzleRoot.rotateZ(Math.PI);
        puzzleRoot.updateMatrixWorld(true);
      }

      // cadrage
      bboxAll = bboxOf(meshes);
      frameOrthoToBox(bboxAll);
    }, undefined, (e)=> console.error('Erreur GLB:', e));

    // UI recentrage
    document.getElementById('faceBtn').addEventListener('click', ()=>{ if(bboxAll) frameOrthoToBox(bboxAll); });
    window.addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='f') document.getElementById('faceBtn').click(); });

    // Resize + render
    function onResize(){
      renderer.setSize(window.innerWidth, window.innerHeight);
      if(bboxAll) frameOrthoToBox(bboxAll);
    }
    window.addEventListener('resize', onResize);

    (function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
