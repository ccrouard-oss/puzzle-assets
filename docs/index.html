<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Puzzle 3D – Planar + Hard-Lock</title>
  <style>
    html,body{height:100%;margin:0;background:#0d1117;color:#e6edf3;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
    #app{position:fixed;inset:0;}
    .hud{position:fixed;left:12px;top:12px;z-index:5;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.08);
      padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px);font-size:13px;line-height:1.35;display:flex;gap:10px;align-items:center}
    .hud b{color:#fff;}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.1);}
    .btn{cursor:pointer;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.06);color:#e6edf3;
      padding:6px 10px;border-radius:8px;font-size:12px}
    .btn:hover{background:rgba(255,255,255,.12)}
    canvas{display:block; touch-action:none;}
  </style>

  <script type="importmap">
  { "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  } }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <div><b>Puzzle 3D</b> – Protect the Oceans</div>
    <div class="badge" id="placedInfo">0 / 50 placées</div>
    <button id="faceBtn" class="btn" title="Recadrer face (touche F)">Face</button>
  </div>
  <audio id="snapSound" src="https://ccrouard-oss.github.io/puzzle-assets/click.mp3" preload="auto"></audio>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    /* ===== CONFIG ===== */
    const MODEL_URL='puzzle_50_scattered.glb';
    const ROWS=5, COLS=10;
    const PUZZLE_W=3.0, PUZZLE_H=4.0;
    const CELL_W=PUZZLE_W/COLS, CELL_H=PUZZLE_H/ROWS;

    // Plan commun et légère élévation visuelle pendant le drag
    const Z_PLANE = 0.0;
    const DRAG_ELEVATION = 0.004;

    // Déplacement posé + magnétisme fiable
    const CAPTURE_RADIUS=Math.min(CELL_W, CELL_H)*0.5;
    const SNAP_EPS_POS=0.006;
    const SNAP_EPS_ROT=0.01;
    const LERP_ALPHA_DRAG=0.25;
    const LERP_ALPHA_SNAP=0.55;
    const MIN_CENTER_DIST=Math.min(CELL_W, CELL_H)*0.22;

    /* ===== SCÈNE ===== */
    const app=document.getElementById('app');
    const placedInfo=document.getElementById('placedInfo');
    const audioEl=document.getElementById('snapSound');

    const scene=new THREE.Scene();
    scene.background=new THREE.Color('#0d1117');

    const camera=new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.01,100);
    camera.position.set(0,0,6.0); camera.up.set(0,1,0);

    const renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.outputColorSpace=THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    scene.add(new THREE.HemisphereLight(0xffffff,0x334466,0.7));
    const dir=new THREE.DirectionalLight(0xffffff,0.85); dir.position.set(2,3,4); scene.add(dir);

    const controls=new OrbitControls(camera,renderer.domElement);
    controls.enableDamping=true; controls.dampingFactor=0.08;
    controls.enableRotate=false; controls.enablePan=true; controls.enableZoom=true;

    // Drag strictement sur le plan z=Z_PLANE
    const dragPlane = new THREE.Plane(new THREE.Vector3(0,0,1), -Z_PLANE);

    const raycaster=new THREE.Raycaster();
    const pointer=new THREE.Vector2();
    const tmpV3=new THREE.Vector3();
    const dragOffsetLocal=new THREE.Vector3();

    function setPointerFromClient(x,y){
      const rect=renderer.domElement.getBoundingClientRect();
      pointer.x=((x-rect.left)/rect.width)*2-1;
      pointer.y=-((y-rect.top)/rect.height)*2+1;
    }
    function screenToWorldOnPlane(clientX, clientY, plane, out){
      setPointerFromClient(clientX, clientY);
      raycaster.setFromCamera(pointer,camera);
      raycaster.ray.intersectPlane(plane,out);
      return out;
    }
    function computePuzzleBBox(meshes){
      const bbox=new THREE.Box3();
      meshes.forEach(m=>bbox.expandByObject(m));
      return bbox;
    }
    function frameFrontView(bbox){
      if(!bbox) return;
      const size=new THREE.Vector3(); bbox.getSize(size);
      const center=bbox.getCenter(new THREE.Vector3());
      const maxDim=Math.max(size.x,size.y);
      const fov=THREE.MathUtils.degToRad(camera.fov);
      const dist=(maxDim*0.62)/Math.tan(fov/2);
      camera.position.set(center.x, center.y, dist);
      camera.lookAt(center);
      controls.target.copy(center);
      controls.update();
    }
    function frontIsVisible(pickable){
      if(!pickable.length) return true;
      const bbox = computePuzzleBBox(pickable);
      const center = bbox.getCenter(new THREE.Vector3());
      const dir = new THREE.Vector3().subVectors(center, camera.position).normalize();
      raycaster.set(camera.position.clone(), dir);
      const hits = raycaster.intersectObjects(pickable, true);
      if(!hits.length) return true;
      const hit = hits[0];
      const normalLocal = hit.face?.normal?.clone() || new THREE.Vector3(0,0,1);
      const normalMatrix = new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld);
      const normalWorld = normalLocal.applyMatrix3(normalMatrix).normalize();
      const surfaceToCamera = new THREE.Vector3().subVectors(camera.position, hit.point).normalize();
      return normalWorld.dot(surfaceToCamera) > 0;
    }

    const loader=new GLTFLoader();
    const pieces=[];
    let puzzleRoot=null, currentBBox=null, pickableMeshes=[];
    let zSorter = 0.0; // pour l’ordre visuel en drag

    loader.load(MODEL_URL,(gltf)=>{
      puzzleRoot=gltf.scene;
      puzzleRoot.rotation.set(0,0,0);
      puzzleRoot.position.set(0,0,Z_PLANE);
      puzzleRoot.updateMatrixWorld(true);
      scene.add(puzzleRoot);

      // Meshes cliquables
      pickableMeshes=[];
      puzzleRoot.traverse(o=>{
        if(o.isMesh){
          pickableMeshes.push(o);
          if(o.material){
            const mats = Array.isArray(o.material) ? o.material : [o.material];
            for(const m of mats){ if(m) m.side = THREE.FrontSide; }
          }
        }
      });

      // Cadrage + flip si nécessaire
      currentBBox=computePuzzleBBox(pickableMeshes);
      frameFrontView(currentBBox);
      if(!frontIsVisible(pickableMeshes)){
        puzzleRoot.rotateX(Math.PI); puzzleRoot.updateMatrixWorld(true);
        if(!frontIsVisible(pickableMeshes)){
          puzzleRoot.rotateX(-Math.PI); puzzleRoot.rotateY(Math.PI); puzzleRoot.updateMatrixWorld(true);
        }
      }
      puzzleRoot.matrixAutoUpdate=false;

      // Regrouper en pièces (noeuds racine)
      const rootSet=new Set();
      for(const m of pickableMeshes){ let n=m; while(n.parent && n.parent!==puzzleRoot) n=n.parent; rootSet.add(n); }
      const roots=[...rootSet];

      // Cibles grille
      const x0=-PUZZLE_W/2+CELL_W/2, y0=PUZZLE_H/2-CELL_H/2;
      let idxAuto=0;
      function parseRowColFromName(name=''){ const m=/r(\d+)_c(\d+)/i.exec(name); return m?{r:+m[1],c:+m[2]}:null; }
      function targetFor(obj){
        const rc=parseRowColFromName(obj.name);
        if(rc) return new THREE.Vector3(x0+rc.c*CELL_W, y0-rc.r*CELL_H, Z_PLANE);
        const r=Math.floor(idxAuto/COLS), c=idxAuto%COLS; idxAuto=(idxAuto+1)%(ROWS*COLS);
        return new THREE.Vector3(x0+c*CELL_W, y0-r*CELL_H, Z_PLANE);
      }

      // Init pièces → toutes à z = Z_PLANE
      roots.forEach(root=>{
        root.position.z = Z_PLANE;
        root.updateMatrixWorld(true);
        pieces.push({
          mesh:root,
          targetPos:targetFor(root),
          targetQuat:new THREE.Quaternion(), // face-on
          placed:false,
          lastSafePos:root.position.clone()
        });
      });

      // Final
      currentBBox=computePuzzleBBox(pickableMeshes);
      frameFrontView(currentBBox);
      updatePlacedCounter();
    }, undefined, (err)=>console.error('Erreur chargement GLB:', err));

    /* ===== Lock helpers ===== */
    function isLocked(node){
      let n=node;
      while(n){
        if(n.userData && n.userData.locked) return true;
        n=n.parent;
      }
      return false;
    }
    function hardLockPiece(entry){
      entry.placed = true;
      // Marquer toute la hiérarchie de la pièce comme verrouillée
      entry.mesh.traverse(o => { if(o.isObject3D){ o.userData = o.userData || {}; o.userData.locked = true; }});
      // Couper le raycast sur le root (empêche toute sélection future)
      entry.mesh.raycast = () => {};
    }

    /* ===== Interaction ===== */
    let dragging=null, dragParent=null;

    function getPoint(e){ return e.touches?.[0] || e.changedTouches?.[0] || e; }
    function findRootPiece(obj){ let n=obj; while(n.parent && n.parent!==puzzleRoot) n=n.parent; return n; }

    function elevateForDrag(mesh){
      zSorter += 0.0005;
      mesh.position.z = Z_PLANE + DRAG_ELEVATION + zSorter;
      mesh.updateMatrixWorld(true);
    }
    function forcePlanar(mesh){
      mesh.position.z = Z_PLANE;
      mesh.updateMatrixWorld(true);
    }

    function pointerDown(e){
      e.preventDefault();
      if(!puzzleRoot) return;
      const { clientX, clientY } = getPoint(e);
      setPointerFromClient(clientX, clientY);
      raycaster.setFromCamera(pointer, camera);
      const hits=raycaster.intersectObjects(pickableMeshes,true)
        .filter(hit => !isLocked(hit.object));
      if(!hits.length) return;

      const rootMesh=findRootPiece(hits[0].object);
      if(isLocked(rootMesh)) return; // sécurité

      const entry=pieces.find(p=>p.mesh===rootMesh);
      if(!entry || entry.placed) return;

      dragging=entry;
      dragParent = entry.mesh.parent || puzzleRoot;
      controls.enabled=false;

      elevateForDrag(entry.mesh);

      // offset de saisie
      const worldHit=screenToWorldOnPlane(clientX,clientY,dragPlane,tmpV3);
      const localHit=dragParent.worldToLocal(worldHit.clone());
      dragOffsetLocal.copy(entry.mesh.position).sub(localHit);

      entry.lastSafePos.copy(entry.mesh.position);
    }

    function pointerMove(e){
      if(!dragging || dragging.placed) return; e.preventDefault();
      const { clientX, clientY } = getPoint(e);
      const worldHit=screenToWorldOnPlane(clientX,clientY,dragPlane,tmpV3);
      const localHit=dragParent.worldToLocal(worldHit.clone()).add(dragOffsetLocal);

      localHit.z = Z_PLANE + DRAG_ELEVATION;
      dragging.mesh.position.lerp(localHit, LERP_ALPHA_DRAG);

      trySnap(dragging,false);
      if(!overlapsAny(dragging)) dragging.lastSafePos.copy(dragging.mesh.position);
    }

    function pointerUp(e){
      e.preventDefault();
      if(dragging){
        if(!dragging.placed){
          trySnap(dragging,true);
          if(!dragging.placed && overlapsAny(dragging)){
            dragging.mesh.position.copy(dragging.lastSafePos);
          }
        }
        forcePlanar(dragging.mesh);
        dragging=null; dragParent=null;
      }
      controls.enabled=true;
    }

    function overlapsAny(entry){
      const p=entry.mesh.position;
      for(const other of pieces){
        if(other===entry) continue;
        if(p.distanceTo(other.mesh.position)<MIN_CENTER_DIST) return true;
      }
      return false;
    }
    function quatAngle(a,b){
      const dot=Math.abs(a.dot(b));
      return Math.acos(Math.min(1,Math.max(-1,2*dot*dot-1)));
    }

    function trySnap(entry, final){
      if(!entry || entry.placed) return;

      const d=entry.mesh.position.distanceTo(entry.targetPos);
      if(d > CAPTURE_RADIUS) return;

      // aimantation
      entry.mesh.position.lerp(entry.targetPos, LERP_ALPHA_SNAP);
      const a=quatAngle(entry.mesh.quaternion, entry.targetQuat);
      if(a>SNAP_EPS_ROT) entry.mesh.quaternion.slerp(entry.targetQuat, 0.6);

      const closePos = entry.mesh.position.distanceTo(entry.targetPos) < SNAP_EPS_POS;
      const closeRot = quatAngle(entry.mesh.quaternion, entry.targetQuat) < SNAP_EPS_ROT;

      if((closePos && closeRot) || final){
        if(!overlapsAny(entry)){
          // verrouillage exact + plan
          entry.mesh.position.copy(entry.targetPos);
          entry.mesh.quaternion.copy(entry.targetQuat);
          forcePlanar(entry.mesh);

          // 🔒 HARD-LOCK : la pièce ne re-bougera plus jamais
          hardLockPiece(entry);

          playSnap(); updatePlacedCounter();
        }
      }
    }

    function playSnap(){ if(!audioEl) return; try{ audioEl.currentTime=0; audioEl.play().catch(()=>{}); }catch{} }
    function updatePlacedCounter(){
      const n=pieces.filter(p=>p.placed).length;
      placedInfo.textContent=`${n} / ${pieces.length || (ROWS*COLS)} placées`;
    }

    function animate(){
      // garde-fou : toute pièce posée reste exactement au plan
      for(const p of pieces){
        if(p.placed && Math.abs(p.mesh.position.z - Z_PLANE) > 1e-6){
          p.mesh.position.z = Z_PLANE;
          p.mesh.updateMatrixWorld(false);
        }
      }
      controls.update();
      renderer.render(scene,camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener('resize', ()=>{
      const w=window.innerWidth, h=window.innerHeight;
      renderer.setSize(w,h);
      camera.aspect=w/h; camera.updateProjectionMatrix();
      if(currentBBox) frameFrontView(currentBBox);
    });

    renderer.domElement.addEventListener('pointerdown',pointerDown,{passive:false});
    window.addEventListener('pointermove', pointerMove,{passive:false});
    window.addEventListener('pointerup',   pointerUp,  {passive:false});
    renderer.domElement.addEventListener('touchstart',pointerDown,{passive:false});
    window.addEventListener('touchmove',  pointerMove,{passive:false});
    window.addEventListener('touchend',   pointerUp,  {passive:false});

    document.getElementById('faceBtn').addEventListener('click', ()=> frameFrontView(currentBBox));
    window.addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='f') frameFrontView(currentBBox); });
  </script>
</body>
</html>
