<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Puzzle 3D – Protect the Oceans</title>
  <style>
    html,body{height:100%;margin:0;background:#0d1117;color:#e6edf3;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
    #app{position:fixed;inset:0;}
    .hud{position:fixed;left:12px;top:12px;z-index:5;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.08);
      padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px);font-size:13px;line-height:1.35;display:flex;gap:10px;align-items:center}
    .hud b{color:#fff;}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.1);}
    .btn{cursor:pointer;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.06);color:#e6edf3;
      padding:6px 10px;border-radius:8px;font-size:12px}
    .btn:hover{background:rgba(255,255,255,.12)}
    canvas{display:block; touch-action:none;} /* important pour le tactile */
  </style>

  <!-- Three.js r160 -->
  <script type="importmap">
  { "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  } }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <div><b>Puzzle 3D</b> – Protect the Oceans</div>
    <div class="badge" id="placedInfo">0 / 50 placées</div>
    <button id="faceBtn" class="btn" title="Recadrer face (touche F)">Face</button>
  </div>

  <audio id="snapSound" src="click.wav" preload="auto"></audio>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ---------------- CONFIG ----------------
    const MODEL_URL = 'puzzle_50_scattered.glb';
    const ROWS=5, COLS=10;
    const PUZZLE_W=3.0, PUZZLE_H=4.0;
    const CELL_W=PUZZLE_W/COLS, CELL_H=PUZZLE_H/ROWS;

    // Magnétisme
    const CAPTURE_RADIUS=0.18, SNAP_EPS_POS=0.002, SNAP_EPS_ROT=0.001;
    const LERP_ALPHA_DRAG=0.6, LERP_ALPHA_SNAP=0.35;
    const LOCK_PLACED=true;

    // Anti-chevauchement (distance mini entre centres hors snap)
    const MIN_CENTER_DIST = Math.min(CELL_W, CELL_H) * 0.18;

    // ---------------- SCÈNE ----------------
    const app=document.getElementById('app');
    const scene=new THREE.Scene();
    scene.background=new THREE.Color('#0d1117');

    // Caméra face (perspective)
    const camera=new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.01,100);
    const PUZZLE_CENTER=new THREE.Vector3(0,0,0);
    camera.position.set(0,0,6.0);
    camera.up.set(0,1,0);
    camera.lookAt(PUZZLE_CENTER);

    const renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.outputColorSpace=THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    // Lumières
    scene.add(new THREE.HemisphereLight(0xffffff,0x334466,0.7));
    const dir=new THREE.DirectionalLight(0xffffff,0.8); dir.position.set(2,3,4); scene.add(dir);

    // Contrôles : libres
    const controls=new OrbitControls(camera,renderer.domElement);
    controls.enableDamping=true; controls.dampingFactor=0.08;
    controls.enableRotate=true; controls.enablePan=true; controls.enableZoom=true;
    controls.target.copy(PUZZLE_CENTER); controls.update();

    // Outils picking/drag
    const raycaster=new THREE.Raycaster();
    const pointer=new THREE.Vector2();
    const tmpV3=new THREE.Vector3();

    // Plan de drag dynamique + offset en LOCAL(parent)
    let dragPlane=null;
    const dragOffsetLocal=new THREE.Vector3();

    function screenToWorldOnPlane(clientX, clientY, plane, out){
      const rect=renderer.domElement.getBoundingClientRect();
      pointer.x=((clientX-rect.left)/rect.width)*2-1;
      pointer.y=-((clientY-rect.top)/rect.height)*2+1;
      raycaster.setFromCamera(pointer,camera);
      raycaster.ray.intersectPlane(plane,out);
      return out;
    }
    function makeScreenDragPlane(cam, worldPoint){
      const n=cam.getWorldDirection(new THREE.Vector3());
      return new THREE.Plane().setFromNormalAndCoplanarPoint(n, worldPoint);
    }
    function worldToParentLocal(obj, worldPoint){
      const parent=obj.parent||scene;
      return parent.worldToLocal(worldPoint.clone());
    }

    // Orientation auto “à plat de face”
    function orientFlatToXY(root){
      const candidates=[{rx:0},{rx:Math.PI/2},{rx:-Math.PI/2}];
      let best={rx:0,score:Infinity};
      const save=root.rotation.clone();
      for(const c of candidates){
        root.rotation.set(c.rx,0,0);
        const bb=new THREE.Box3().setFromObject(root);
        const size=bb.getSize(new THREE.Vector3());
        const score=size.z;
        if(score<best.score) best={rx:c.rx,score};
      }
      root.rotation.copy(save);
      root.rotation.set(best.rx,0,0);
    }

    // ---------------- CHARGEMENT ----------------
    const loader=new GLTFLoader();
    const pieces=[];          // { mesh: rootPiece, target:{position,quaternion}, placed }
    let puzzleRoot=null, currentBBox=null;
    let pickableMeshes=[];    // tous les Meshs pour le raycast

    loader.load(MODEL_URL,(gltf)=>{
      puzzleRoot=gltf.scene;
      scene.add(puzzleRoot);

      orientFlatToXY(puzzleRoot);
      puzzleRoot.updateMatrixWorld(true);
      puzzleRoot.matrixAutoUpdate=false; // parent stable

      // 1) Collecte tous les Mesh (pour le picking)
      pickableMeshes=[];
      puzzleRoot.traverse(o=>{ if(o.isMesh) pickableMeshes.push(o); });

      // 2) Déduit les pièces-racines : on remonte jusqu'au PREMIER enfant de puzzleRoot
      const rootSet=new Set();
      for(const m of pickableMeshes){
        let node=m;
        while(node.parent && node.parent!==puzzleRoot) node=node.parent;
        rootSet.add(node);
      }
      const roots=[...rootSet];

      // 3) Initialise les pièces
      roots.forEach(root=>{
        pieces.push({
          mesh: root,
          target: computeTargetTransform(root),
          placed: false
        });
      });

      // Cadrage face + bbox
      currentBBox=computePuzzleBBox(pieces.map(p=>p.mesh));
      frameFrontView(currentBBox);

      // Z cible = 0
      pieces.forEach(p=>p.target.position.z=0);

      updatePlacedCounter();
    }, undefined, (err)=>console.error('Erreur chargement GLB:', err));

    // Grille/nommage
    function parseRowColFromName(name=''){
      const m=/r(\d+)_c(\d+)/i.exec(name);
      return m?{r:+m[1],c:+m[2]}:null;
    }
    let fallbackIndexCounter=0;
    function computeTargetTransform(obj){
      if(obj.userData && obj.userData.home){
        const {pos,quat}=obj.userData.home;
        return {
          position:new THREE.Vector3(pos.x,pos.y,pos.z),
          quaternion:new THREE.Quaternion(quat.x,quat.y,quat.z,quat.w)
        };
      }
      const rc=parseRowColFromName(obj.name);
      const x0=-PUZZLE_W/2+CELL_W/2, y0=PUZZLE_H/2-CELL_H/2;
      if(rc){
        return { position:new THREE.Vector3(x0+rc.c*CELL_W, y0-rc.r*CELL_H, 0),
                 quaternion:new THREE.Quaternion() };
      }
      const idx=(fallbackIndexCounter++ % (ROWS*COLS));
      const r=Math.floor(idx/COLS), c=idx%COLS;
      return { position:new THREE.Vector3(x0+c*CELL_W, y0-r*CELL_H, 0),
               quaternion:new THREE.Quaternion() };
    }

    // BBox & cadrage face
    function computePuzzleBBox(meshes){
      const bbox=new THREE.Box3();
      meshes.forEach(m=>bbox.expandByObject(m));
      return bbox;
    }
    function frameFrontView(bbox){
      if(!bbox) return;
      const size=new THREE.Vector3(); bbox.getSize(size);
      const center=bbox.getCenter(new THREE.Vector3());
      const maxDim=Math.max(size.x,size.y);
      const fov=THREE.MathUtils.degToRad(camera.fov);
      const dist=(maxDim*0.6)/Math.tan(fov/2);

      camera.position.set(center.x, center.y, dist);
      camera.up.set(0,1,0);
      camera.lookAt(center);
      controls.target.copy(center);
      controls.update();
    }

    // ---------------- DRAG & MAGNÉTISME ----------------
    const placedInfo=document.getElementById('placedInfo');
    const audioEl=document.getElementById('snapSound');

    let dragging=null;
    let dragStartPos=null;

    function getPoint(e){ return e.touches?.[0] || e.changedTouches?.[0] || e; }
    function setPointer(x,y){
      const rect=renderer.domElement.getBoundingClientRect();
      pointer.x=((x-rect.left)/rect.width)*2-1;
      pointer.y=-((y-rect.top)/rect.height)*2+1;
    }
    function findRootPiece(obj){
      // remonte jusqu'au premier enfant de puzzleRoot
      let node=obj;
      while(node.parent && node.parent!==puzzleRoot) node=node.parent;
      return node;
    }

    function pointerDown(e){
      e.preventDefault();
      const { clientX, clientY } = getPoint(e);
      setPointer(clientX, clientY);
      raycaster.setFromCamera(pointer, camera);

      // pick parmi TOUS les Meshes, puis remonte vers la pièce-racine
      const hits = raycaster.intersectObjects(pickableMeshes, true)
        .filter(hit => {
          const root = findRootPiece(hit.object);
          return root && !(root.userData && root.userData.locked);
        });

      if (!hits.length) return;

      const rootMesh  = findRootPiece(hits[0].object);
      const entry     = pieces.find(p => p.mesh === rootMesh);
      if (!entry) return;

      dragging = entry;
      dragStartPos = entry.mesh.position.clone();
      controls.enabled = false;

      // plan de drag aligné à l'écran, passant par la position MONDE de la pièce
      const pieceWorld = new THREE.Vector3();
      entry.mesh.getWorldPosition(pieceWorld);
      dragPlane = makeScreenDragPlane(camera, pieceWorld);

      // point monde → local(parent) + offset local
      const worldHit = screenToWorldOnPlane(clientX, clientY, dragPlane, tmpV3);
      const localHit = worldToParentLocal(entry.mesh, worldHit);
      dragOffsetLocal.copy(entry.mesh.position).sub(localHit);
    }

    function pointerMove(e){
      if (!dragging) return;
      e.preventDefault();
      const { clientX, clientY } = getPoint(e);

      const worldHit = screenToWorldOnPlane(clientX, clientY, dragPlane, tmpV3);
      const localHit = worldToParentLocal(dragging.mesh, worldHit).add(dragOffsetLocal);
      dragging.mesh.position.lerp(localHit, LERP_ALPHA_DRAG);

      tryMagnet(dragging);
    }

    function pointerUp(e){
      e.preventDefault();
      if (dragging) {
        tryMagnet(dragging, true);
        if (!dragging.placed && overlapsAny(dragging)) {
          dragging.mesh.position.copy(dragStartPos);
        }
        dragging = null;
      }
      controls.enabled = true;
    }

    function overlapsAny(entry){
      const pos = entry.mesh.position;
      for (const other of pieces){
        if (other === entry) continue;
        const d = pos.distanceTo(other.mesh.position);
        if (d < MIN_CENTER_DIST) return true;
      }
      return false;
    }

    function angleBetweenQuats(a,b){
      const dot=Math.abs(a.dot(b));
      return Math.acos(Math.min(1,Math.max(-1,2*dot*dot-1)));
    }
    function tryMagnet(entry, final=false){
      if(!entry || entry.placed) return;
      const mesh=entry.mesh, tgt=entry.target;

      const d=mesh.position.distanceTo(tgt.position);
      if(d>CAPTURE_RADIUS) return;

      mesh.position.lerp(tgt.position, LERP_ALPHA_SNAP);
      const a=angleBetweenQuats(mesh.quaternion, tgt.quaternion);
      if(a>SNAP_EPS_ROT) mesh.quaternion.slerp(tgt.quaternion, LERP_ALPHA_SNAP);

      const close = d<SNAP_EPS_POS && a<SNAP_EPS_ROT;
      if(close || final){
        if(mesh.position.distanceTo(tgt.position)<2*SNAP_EPS_POS &&
           angleBetweenQuats(mesh.quaternion, tgt.quaternion)<2*SNAP_EPS_ROT){
          mesh.position.copy(tgt.position);
          mesh.quaternion.copy(tgt.quaternion);
          entry.placed=true;
          if(LOCK_PLACED) mesh.userData.locked=true;
          playSnap(); updatePlacedCounter();
        }
      }
    }

    function playSnap(){
      if(!audioEl) return;
      try{ audioEl.currentTime=0; audioEl.play().catch(()=>{}); }catch{}
    }
    function updatePlacedCounter(){
      const n=pieces.filter(p=>p.placed).length;
      placedInfo.textContent=`${n} / ${pieces.length || (ROWS*COLS)} placées`;
    }

    // ---------------- RENDER ----------------
    function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); }
    animate();

    // Resize
    window.addEventListener('resize', ()=>{
      const w=window.innerWidth, h=window.innerHeight;
      renderer.setSize(w,h);
      camera.aspect=w/h; camera.updateProjectionMatrix();
      if (currentBBox) frameFrontView(currentBBox);
    });

    // Events (souris/tactile)
    renderer.domElement.addEventListener('pointerdown',pointerDown,{passive:false});
    window.addEventListener('pointermove', pointerMove,{passive:false});
    window.addEventListener('pointerup',   pointerUp,  {passive:false});
    renderer.domElement.addEventListener('touchstart',pointerDown,{passive:false});
    window.addEventListener('touchmove',  pointerMove,{passive:false});
    window.addEventListener('touchend',   pointerUp,  {passive:false});

    // Bouton “Face” + touche F
    const faceBtn=document.getElementById('faceBtn');
    faceBtn.addEventListener('click', ()=> frameFrontView(currentBBox));
    window.addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='f') frameFrontView(currentBBox); });
  </script>
</body>
</html>
