<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Puzzle 3D – Protect the Oceans</title>
  <style>
    html,body{height:100%;margin:0;background:#0d1117;color:#e6edf3;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
    #app{position:fixed;inset:0;}
    .hud{position:fixed;left:12px;top:12px;z-index:5;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.08);
      padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px);font-size:13px;line-height:1.35;}
    .hud b{color:#fff;}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.1);}
    canvas{display:block;}
  </style>

  <!-- Import map Three.js r160 -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <div><b>Puzzle 3D</b> – Protect the Oceans</div>
    <div class="badge" id="placedInfo">0 / 50 placées</div>
  </div>

  <audio id="snapSound" src="click.wav" preload="auto"></audio>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ---------------- CONFIG ----------------
    const MODEL_URL = 'puzzle_50_scattered.glb';
    const ROWS=5, COLS=10;
    const PUZZLE_W=3.0, PUZZLE_H=4.0;
    const CELL_W=PUZZLE_W/COLS, CELL_H=PUZZLE_H/ROWS;
    const CAPTURE_RADIUS=0.18, SNAP_EPS_POS=0.002, SNAP_EPS_ROT=0.001;
    const LERP_ALPHA_DRAG=0.6, LERP_ALPHA_SNAP=0.35;
    const LOCK_PLACED=true;

    // -------------- SCÈNE ----------------
    const app=document.getElementById('app');
    const scene=new THREE.Scene();
    scene.background=new THREE.Color('#0d1117');

    const camera=new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.01,100);
    const PUZZLE_CENTER=new THREE.Vector3(0,0,0);

    // Caméra inclinée de 15° vers le bas (rotation sur X)
    const DISTANCE = 5.5; // distance de la caméra
    const ANGLE_DEGREES = 15;
    const ANGLE = THREE.MathUtils.degToRad(ANGLE_DEGREES);
    camera.position.set(0, Math.sin(ANGLE) * DISTANCE, Math.cos(ANGLE) * DISTANCE);
    camera.lookAt(PUZZLE_CENTER);

    const renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setSize(window.innerWidth,window.innerHeight);
    renderer.outputColorSpace=THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    // Lumières
    const hemi=new THREE.HemisphereLight(0xffffff,0x334466,0.7);
    scene.add(hemi);
    const dir=new THREE.DirectionalLight(0xffffff,0.8);
    dir.position.set(2,3,4);
    scene.add(dir);

    // Contrôles libres
    const controls=new OrbitControls(camera,renderer.domElement);
    controls.enableDamping=true;
    controls.dampingFactor=0.08;
    controls.enableRotate=true;
    controls.enablePan=true;
    controls.enableZoom=true;
    controls.target.copy(PUZZLE_CENTER);
    controls.update();

    // ---------------- OUTILS ----------------
    const raycaster=new THREE.Raycaster();
    const pointer=new THREE.Vector2();
    const tmpV3=new THREE.Vector3();
    const dragPlane=new THREE.Plane(new THREE.Vector3(0,0,1),0);

    function screenToWorldOnPlane(x,y,plane,out){
      const rect=renderer.domElement.getBoundingClientRect();
      pointer.x=((x-rect.left)/rect.width)*2-1;
      pointer.y=-((y-rect.top)/rect.height)*2+1;
      raycaster.setFromCamera(pointer,camera);
      raycaster.ray.intersectPlane(plane,out);
      return out;
    }

    // ---------------- CHARGEMENT ----------------
    const loader=new GLTFLoader();
    const pieces=[];
    let puzzleRoot=null;

    loader.load(MODEL_URL,(gltf)=>{
      puzzleRoot=gltf.scene;
      scene.add(puzzleRoot);
      const meshes=[];
      puzzleRoot.traverse(o=>{if(o.isMesh)meshes.push(o);});
      meshes.forEach(m=>pieces.push({mesh:m,target:computeTargetTransform(m),placed:false}));
      const bbox=computePuzzleBBox(pieces.map(p=>p.mesh));
      frameFrontView(bbox);
      pieces.forEach(p=>p.target.position.z=0);
      updatePlacedCounter();
    });

    function parseRowColFromName(name){
      const m=/r(\d+)_c(\d+)/i.exec(name);
      return m?{r:+m[1],c:+m[2]}:null;
    }

    function computeTargetTransform(obj){
      if(obj.userData&&obj.userData.home){
        const {pos,quat}=obj.userData.home;
        return{
          position:new THREE.Vector3(pos.x,pos.y,pos.z),
          quaternion:new THREE.Quaternion(quat.x,quat.y,quat.z,quat.w)
        };
      }
      const rc=parseRowColFromName(obj.name);
      const x0=-PUZZLE_W/2+CELL_W/2,y0=PUZZLE_H/2-CELL_H/2;
      if(rc)
        return{position:new THREE.Vector3(x0+rc.c*CELL_W,y0-rc.r*CELL_H,0),quaternion:new THREE.Quaternion()};
      return{position:new THREE.Vector3(0,0,0),quaternion:new THREE.Quaternion()};
    }

    function computePuzzleBBox(meshes){
      const bbox=new THREE.Box3();
      meshes.forEach(m=>bbox.expandByObject(m));
      return bbox;
    }

    function frameFrontView(bbox){
      const size=new THREE.Vector3();bbox.getSize(size);
      const maxDim=Math.max(size.x,size.y);
      const fov=THREE.MathUtils.degToRad(camera.fov);
      const dist=(maxDim*0.6)/Math.tan(fov/2);
      camera.lookAt(bbox.getCenter(new THREE.Vector3()));
      controls.target.copy(bbox.getCenter(new THREE.Vector3()));
      controls.update();
    }

    // ------------- DRAG & MAGNÉTISME -------------
    const placedInfo=document.getElementById('placedInfo');
    const audioEl=document.getElementById('snapSound');
    let dragging=null;
    const dragOffset=new THREE.Vector3();

    function pointerDown(e){
      const {clientX,clientY}=getPoint(e);
      setPointer(clientX,clientY);
      raycaster.setFromCamera(pointer,camera);
      const hits=raycaster.intersectObjects(pieces.map(p=>p.mesh),true)
        .filter(h=>!h.object.userData.locked);
      if(hits.length){
        const mesh=hits[0].object;
        dragging=pieces.find(p=>p.mesh===mesh||p.mesh===mesh.parent);
        if(dragging){
          const w=screenToWorldOnPlane(clientX,clientY,dragPlane,tmpV3);
          dragOffset.copy(dragging.mesh.position).sub(w);
        }
      }
    }
    function pointerMove(e){
      if(!dragging)return;
      const {clientX,clientY}=getPoint(e);
      const w=screenToWorldOnPlane(clientX,clientY,dragPlane,tmpV3);
      w.add(dragOffset);
      dragging.mesh.position.lerp(w,LERP_ALPHA_DRAG);
      tryMagnet(dragging);
    }
    function pointerUp(){
      if(dragging){tryMagnet(dragging,true);dragging=null;}
    }
    function getPoint(e){return e.touches?.[0]||e.changedTouches?.[0]||e;}
    function setPointer(x,y){
      const rect=renderer.domElement.getBoundingClientRect();
      pointer.x=((x-rect.left)/rect.width)*2-1;
      pointer.y=-((y-rect.top)/rect.height)*2+1;
    }
    function angleBetweenQuats(a,b){
      const dot=Math.abs(a.dot(b));
      return Math.acos(Math.min(1,Math.max(-1,2*dot*dot-1)));
    }
    function tryMagnet(entry,final=false){
      if(!entry||entry.placed)return;
      const mesh=entry.mesh,tgt=entry.target;
      const d=mesh.position.distanceTo(tgt.position);
      if(d>CAPTURE_RADIUS)return;
      mesh.position.lerp(tgt.position,LERP_ALPHA_SNAP);
      const a=angleBetweenQuats(mesh.quaternion,tgt.quaternion);
      if(a>SNAP_EPS_ROT)mesh.quaternion.slerp(tgt.quaternion,LERP_ALPHA_SNAP);
      const close=d<SNAP_EPS_POS&&a<SNAP_EPS_ROT;
      if(close||final){
        if(mesh.position.distanceTo(tgt.position)<2*SNAP_EPS_POS&&angleBetweenQuats(mesh.quaternion,tgt.quaternion)<2*SNAP_EPS_ROT){
          mesh.position.copy(tgt.position);
          mesh.quaternion.copy(tgt.quaternion);
          entry.placed=true;
          if(LOCK_PLACED)mesh.userData.locked=true;
          playSnap();updatePlacedCounter();
        }
      }
    }
    function playSnap(){
      if(!audioEl)return;
      try{audioEl.currentTime=0;audioEl.play().catch(()=>{});}catch{}
    }
    function updatePlacedCounter(){
      const n=pieces.filter(p=>p.placed).length;
      placedInfo.textContent=`${n} / ${pieces.length||ROWS*COLS} placées`;
    }

    // -------------- RENDER LOOP --------------
    function animate(){requestAnimationFrame(animate);controls.update();renderer.render(scene,camera);}
    animate();

    window.addEventListener('resize',()=>{
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    });

    renderer.domElement.addEventListener('pointerdown',pointerDown,{passive:false});
    window.addEventListener('pointermove',pointerMove,{passive:false});
    window.addEventListener('pointerup',pointerUp,{passive:false});
    renderer.domElement.addEventListener('touchstart',pointerDown,{passive:false});
    window.addEventListener('touchmove',pointerMove,{passive:false});
    window.addEventListener('touchend',pointerUp,{passive:false});
  </script>
</body>
</html>
