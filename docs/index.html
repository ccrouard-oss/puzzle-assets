<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Puzzle – 2D strict (déplacement fluide + aimantation robuste)</title>
  <style>
    html,body{
      height:100%;
      margin:0;
      background:#0d1117;
      color:#e6edf3;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    }

    /* === Correction : centrage du puzzle === */
    #app {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .hud {
      position: fixed;
      left: 12px;
      top: 12px;
      z-index: 5;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.08);
      padding: 8px 10px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      font-size: 13px;
      line-height: 1.35;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .badge { display:inline-block; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.1) }
    .btn   { cursor:pointer; border:1px solid rgba(255,255,255,.16); background:rgba(255,255,255,.06); color:#e6edf3; padding:6px 10px; border-radius:8px; font-size:12px }

    canvas {
      display:block;
      margin:auto;           /* <-- double sécurité de centrage */
      touch-action:none;
      max-width:100%;
      max-height:100%;
    }
  </style>

  <script type="importmap">
    { "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    } }
  </script>
</head>
<body>
  <div id="app"></div>

  <div class="hud">
    <div class="badge">Mode: 2D strict</div>
    <div class="badge" id="groupInfo">Bloc: 1 pièce</div>
    <div class="badge" id="placedInfo">0 placées</div>
    <label style="display:flex;gap:6px;align-items:center">
      <input type="checkbox" id="lockAfterMerge" checked /> Verrouiller blocs assemblés
    </label>
    <button class="btn" id="resetBtn">Réinitialiser</button>
  </div>

  <!-- Son optionnel : si absent, le code continue sans erreur -->
  <audio id="snapSound" src="click.mp3" preload="auto"></audio>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ========= CONFIG (4:3 PORTRAIT, 2D STRICT) ==============================
    const MODEL_URL = 'puzzle_50_scattered.glb';   // même dossier que index3.html
    const ROWS=5, COLS=10;
    const PUZZLE_W=3.0, PUZZLE_H=4.0;              // 4:3 portrait
    const CELL_W=PUZZLE_W/COLS, CELL_H=PUZZLE_H/ROWS;

    // — Déplacement fluide & aimantation
    const POS_EPS = 0.003;
    const LERP_DRAG = 0.35;        // lissage du drag
    const LERP_SNAP = 0.5;         // accélération vers la cible

    // — Seuils d'aimantation (2D)
    const SNAP_GRID = 0.18;        // capture sur la cible absolue
    const SNAP_NEIGH_EAGER = 0.14; // aimantation immédiate (voisin exact)
    const SNAP_NEIGH = 0.2;        // voisinage "proche" (drag continu)

    // — Hystérésis (bande collante pour éviter le papillonnement)
    const STICKY_BAND = 0.25;

    // Anti-chevauchement (distance minimale entre centres de blocs)
    const MIN_CENTER_DIST = Math.min(CELL_W, CELL_H)*0.42;

    // Bornes XY de l'aire de jeu
    const BOUNDS_MARGIN = 0.6;

    // ========= SCÈNE =========================================================
    const app = document.getElementById('app');
    const scene = new THREE.Scene(); scene.background = new THREE.Color('#0d1117');

    // Caméra orthographique unique (2D stricte)
    function makeOrtho(){
      const aspect = window.innerWidth / window.innerHeight;
      const viewH = PUZZLE_H * 1.15; // marge
      const viewW = viewH * aspect;
      return new THREE.OrthographicCamera(-viewW/2, viewW/2, viewH/2, -viewH/2, -10, 10);
    }
    const camera = makeOrtho();
    camera.position.set(0,0,5); camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    scene.add(new THREE.HemisphereLight(0xffffff,0x223344,0.8));
    const dl = new THREE.DirectionalLight(0xffffff,0.6); dl.position.set(2,3,4); scene.add(dl);

    // Raycast & pointeur
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    const puzzleRoot = new THREE.Group(); scene.add(puzzleRoot);
    const pickableMeshes = [];
    const entriesByName = new Map();
    const entries = [];

    const x0 = -PUZZLE_W/2 + CELL_W/2;
    const y0 =  PUZZLE_H/2 - CELL_H/2;
    const targetOf = (rc)=> new THREE.Vector3(x0 + rc.c*CELL_W, y0 - rc.r*CELL_H, 0);

    // ======== UTILITAIRES MANQUANTS (restaurés) ==============================
    function forcePlanarZ(root, z=0){
      root.traverse(o=>{ if(o.position) o.position.z = z; });
    }
    function reparentKeepWorld(child, newParent){
      const wp = new THREE.Vector3(); child.getWorldPosition(wp);
      const wq = new THREE.Quaternion(); child.getWorldQuaternion(wq);
      newParent.add(child);
      child.position.copy(newParent.worldToLocal(wp));
      const inv = newParent.getWorldQuaternion(new THREE.Quaternion()).invert();
      child.quaternion.copy(inv.multiply(wq));
      child.scale.set(1,1,1);
    }

    // ======== CHARGEMENT GLB ================================================
    const loader = new GLTFLoader();
    loader.load(MODEL_URL, (gltf)=>{
      const root = gltf.scene;
      root.traverse(o=>{
        if(o.isMesh){
          pickableMeshes.push(o);
          const mats = Array.isArray(o.material)? o.material : [o.material];
          for(const m of mats){ if(m){ m.side = THREE.FrontSide; } }
        }
      });
      orientFaceOn(root);

      for(const rNode of uniqueRootsUnder(root)){
        const rc = parseRC(rNode.name) || {r:0,c:0};
        const block = reparentAsBlock(rNode, puzzleRoot);
        const entry = { group:block, mesh:rNode, rc, target:targetOf(rc), placed:false, stickyTo:null };
        entries.push(entry);
        entriesByName.set(`r${rc.r}_c${rc.c}`, entry);
      }

      forcePlanarZ(puzzleRoot, 0);
      updateHUD();
      render();
    }, undefined, err=>console.error(err));

    function orientFaceOn(root){
      root.rotation.set(0,0,0);
      root.updateMatrixWorld(true);
      const bbox = new THREE.Box3().setFromObject(root);
      if(bbox.getSize(new THREE.Vector3()).z > 0.2){
        root.rotation.x = Math.PI/2; // remet à plat si import en "tranche"
        root.updateMatrixWorld(true);
      }
    }
    function uniqueRootsUnder(root){
      const set = new Set();
      for(const m of pickableMeshes){
        let n=m; while(n.parent && n.parent!==root) n=n.parent;
        set.add(n);
      }
      return [...set];
    }
    function parseRC(name=''){
      const m = /r(\d+)_c(\d+)/i.exec(name);
      return m? {r:+m[1], c:+m[2]} : null;
    }
    function reparentAsBlock(node, parent){
      const block = new THREE.Group();
      parent.add(block);
      node.updateMatrixWorld(true);
      const wp = new THREE.Vector3(); node.getWorldPosition(wp);
      const wq = new THREE.Quaternion(); node.getWorldQuaternion(wq);
      block.position.copy(wp); block.quaternion.copy(wq); block.scale.set(1,1,1);
      block.add(node);
      node.position.set(0,0,0); node.quaternion.identity(); node.scale.set(1,1,1);
      return block;
    }

    // ======== DRAG/SNAP/COLLISION (2D) =======================================
    let dragging = null;
    let dragOffset = new THREE.Vector3(); // offset clic→centre
    const dragPlane = new THREE.Plane(new THREE.Vector3(0,0,1), 0); // z=0

    function setPointer(e){
      const p = e.touches?.[0] || e.changedTouches?.[0] || e;
      const rect=renderer.domElement.getBoundingClientRect();
      pointer.x=((p.clientX-rect.left)/rect.width)*2-1;
      pointer.y=-((p.clientY-rect.top)/rect.height)*2+1;
      return p;
    }
    function rayFromPointer(){
      const r = new THREE.Ray();
      const origin = new THREE.Vector3(pointer.x, pointer.y, 0).unproject(camera);
      const dir = new THREE.Vector3(0,0,-1).transformDirection(camera.matrixWorld);
      r.origin.copy(origin); r.direction.copy(dir);
      return r;
    }
    function intersectPickable(){
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(pickableMeshes, true);
      for(const h of hits){
        const e = entryFromObject(h.object);
        if(e) return {entry:e, hitPoint:h.point};
      }
      return null;
    }
    function entryFromObject(obj){
      let n = obj;
      while(n && n.parent && n.parent!==puzzleRoot) n = n.parent;
      if(!n) return null;
      return entries.find(e=>e.group===n) || null;
    }
    function findBlock(g){
      let n=g; while(n.parent && n.parent!==puzzleRoot) n=n.parent;
      return n||g;
    }
    function clampInBounds(v){
      const halfW = PUZZLE_W/2 + BOUNDS_MARGIN;
      const halfH = PUZZLE_H/2 + BOUNDS_MARGIN;
      v.x = Math.max(-halfW, Math.min(halfW, v.x));
      v.y = Math.max(-halfH, Math.min(halfH, v.y));
      v.z = 0;
    }

    function neighRCs(rc){
      const list=[];
      if(rc.r>0)      list.push({r:rc.r-1,c:rc.c, dx:0,        dy:+CELL_H});
      if(rc.r<ROWS-1) list.push({r:rc.r+1,c:rc.c, dx:0,        dy:-CELL_H});
      if(rc.c>0)      list.push({r:rc.r,  c:rc.c-1, dx:-CELL_W,dy:0});
      if(rc.c<COLS-1) list.push({r:rc.r,  c:rc.c+1, dx:+CELL_W,dy:0});
      return list;
    }

    function isIntendedNeighbor(entry, other){
      const rc = entry.rc;
      return neighRCs(rc).some(n => `r${n.r}_c${n.c}` === `r${other.rc.r}_c${other.rc.c}`);
    }

    // — anti-chevauchement (résolution douce)
    function resolveCollisionsFor(entry, ignoreForSnap=false){
      const A = findBlock(entry.group);
      const posA = A.position;
      for(const e of entries){
        const B = findBlock(e.group);
        if(B===A) continue;
        if(!ignoreForSnap && isIntendedNeighbor(entry, e)) continue; // pas de répulsion pour le voisin logique
        const posB = B.position;
        const delta = new THREE.Vector3().subVectors(posA, posB);
        const dist = delta.length();
        if(dist < MIN_CENTER_DIST){
          if(dist < 1e-6){
            delta.set(Math.random()-0.5, Math.random()-0.5, 0).normalize().multiplyScalar(MIN_CENTER_DIST);
          }else{
            delta.multiplyScalar((MIN_CENTER_DIST - dist)/dist);
          }
          posA.add(delta);
          clampInBounds(posA);
        }
      }
    }

    // — SNAP GRILLE & VOISINS
    const audioEl = document.getElementById('snapSound');
    function playSnap(){
      if(!audioEl) return;
      try{
        audioEl.currentTime = 0;
        const p = audioEl.play();
        if(p && typeof p.catch === 'function'){ p.catch(()=>{}); }
      }catch{}
    }

    function trySnapGrid(entry, final){
      const d = entry.group.position.distanceTo(entry.target);
      if(!final && d>SNAP_GRID) return false;
      const aim = entry.target.clone();
      if(final || d < SNAP_NEIGH_EAGER){ entry.group.position.copy(aim);} else { entry.group.position.lerp(aim, LERP_SNAP); }
      entry.group.position.z = 0;

      const ok = entry.group.position.distanceTo(aim) < (final? 2*POS_EPS : 0.02);
      if(ok){
        entry.group.position.copy(aim);
        entry.group.position.z = 0;
        entry.placed = true; entry.stickyTo = null;
        forcePlanarZ(findBlock(entry.group), 0);
        playSnap(); updateHUD();
        return true;
      }
      return false;
    }

    function trySnapNeighbors(entry, final){
      const rc = entry.rc;
      const posA = entry.group.position;

      // garder l'accroche si déjà collé à un voisin
      if(entry.stickyTo){
        const { nbKey, desired } = entry.stickyTo;
        const nb = entriesByName.get(nbKey);
        if(nb){
          const posB = nb.group.position;
          const dist = new THREE.Vector3().subVectors(posB, posA).sub(desired).length();
          if(dist < STICKY_BAND){
            const newPosA = new THREE.Vector3().subVectors(posB, desired);
            if(final || dist < SNAP_NEIGH_EAGER){ posA.copy(newPosA);} else { posA.lerp(newPosA, LERP_SNAP); }
            posA.z = 0;
            return true;
          } else {
            entry.stickyTo = null;
          }
        } else {
          entry.stickyTo = null;
        }
      }

      // choisir le meilleur voisin
      let best = null;
      for(const n of neighRCs(rc)){
        const nb = entriesByName.get(`r${n.r}_c${n.c}`);
        if(!nb) continue;

        const blockA = findBlock(entry.group);
        const blockB = findBlock(nb.group);
        if(blockA===blockB) continue;

        const posB = nb.group.position;
        const desired = new THREE.Vector3(n.dx, n.dy, 0);
        const dist = new THREE.Vector3().subVectors(posB, posA).sub(desired).length();
        if(best===null || dist < best.dist){ best = { nb, desired, dist, nbKey:`r${n.r}_c${n.c}` }; }
      }
      if(!best) return false;

      const eager = best.dist < SNAP_NEIGH_EAGER;
      const near  = best.dist < (final? 2*POS_EPS : SNAP_NEIGH);
      if(eager || near){
        const blockA = findBlock(entry.group);
        const blockB = findBlock(best.nb.group);
        const newPosA = new THREE.Vector3().subVectors(best.nb.group.position, best.desired);
        if(eager || final){ posA.copy(newPosA);} else { posA.lerp(newPosA, LERP_SNAP); }
        posA.z = 0;

        mergeBlocks(blockA, blockB);
        forcePlanarZ(findBlock(entry.group), 0);
        entry.stickyTo = { nbKey: best.nbKey, desired: best.desired.clone() };
        playSnap(); updateHUD();
        return true;
      }
      return false;
    }

    function mergeBlocks(A, B){
      if(A===B) return;
      const parent = new THREE.Group(); puzzleRoot.add(parent);
      const pa = new THREE.Vector3(); A.getWorldPosition(pa);
      const pb = new THREE.Vector3(); B.getWorldPosition(pb);
      parent.position.copy(pa.add(pb).multiplyScalar(0.5));
      reparentKeepWorld(A, parent);
      reparentKeepWorld(B, parent);
      forcePlanarZ(parent, 0);

      // Bloc indissociable : on le marque "locked" si l’option est cochée
      parent.userData.locked = document.getElementById('lockAfterMerge').checked;

      // Rattacher les entrées au nouveau parent
      for(const e of entries){
        const r = findBlock(e.group);
        if(r===A || r===B || r===parent){ e.group = parent; e.placed = true; }
      }
    }

    // ======== INPUTS =========================================================
    function pointerDown(e){
      e.preventDefault();
      setPointer(e);
      const pick = intersectPickable();
      if(!pick) return;
      const { entry, hitPoint } = pick;
      const root = findBlock(entry.group);
      if(root.userData.locked) return; // bloc verrouillé

      dragging = entry;

      // offset clic→centre pour suivi précis
      const center = root.position.clone();
      dragOffset.copy(hitPoint.clone().sub(center));
      dragOffset.z = 0;
    }
    function pointerMove(e){
      if(!dragging) return;
      e.preventDefault();
      setPointer(e);

      const ray = rayFromPointer();
      const hit = new THREE.Vector3();
      if(!ray.intersectPlane(dragPlane, hit)) return;

      const pos = dragging.group.position;
      const target = hit.sub(dragOffset);
      pos.lerp(target, LERP_DRAG);
      clampInBounds(pos);

      const snappedNeighbor = trySnapNeighbors(dragging, false);
      if(snappedNeighbor) return;

      const snappedGrid = trySnapGrid(dragging, false);
      if(snappedGrid) return;

      resolveCollisionsFor(dragging, /*ignoreForSnap=*/false);
    }
    function pointerUp(e){
      if(!dragging) return;
      e.preventDefault();
      if(!trySnapNeighbors(dragging, true)) trySnapGrid(dragging, true);
      dragging = null;
    }

    // ======== HUD / RENDER ===================================================
    const placedInfo = document.getElementById('placedInfo');
    const groupInfo  = document.getElementById('groupInfo');

    function updateHUD(){
      const nPlaced = entries.filter(e=>e.placed).length;
      placedInfo.textContent = `${nPlaced} placées`;
      const blk = dragging? findBlock(dragging.group) : null;
      const count = blk? countPieces(blk):1;
      groupInfo.textContent = `Bloc: ${count} pièce${count>1?'s':''}`;
    }
    function countPieces(block){
      let c=0; for(const e of entries){ if(findBlock(e.group)===findBlock(block)) c++; }
      return c||1;
    }

    function render(){ requestAnimationFrame(render); updateHUD(); renderer.render(scene, camera); }

    // Resize
    window.addEventListener('resize', ()=>{
      const aspect = window.innerWidth / window.innerHeight;
      const viewH = PUZZLE_H * 1.15;
      const viewW = viewH * aspect;
      camera.left = -viewW/2; camera.right = viewW/2; camera.top = viewH/2; camera.bottom = -viewH/2;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Inputs souris / tactile
    renderer.domElement.addEventListener('pointerdown', pointerDown, {passive:false});
    renderer.domElement.addEventListener('pointermove', pointerMove, {passive:false});
    window.addEventListener('pointerup', pointerUp, {passive:false});

    // Réinitialiser positions aléatoires de départ
    document.getElementById('resetBtn').addEventListener('click', ()=>{
      const M = 0.8; // étendue du mélange
      for(const e of entries){
        const jitter = new THREE.Vector3((Math.random()-0.5)*M, (Math.random()-0.5)*M, 0);
        e.group.position.copy(e.target.clone().add(jitter));
        e.group.position.z = 0; e.placed=false; e.stickyTo=null;
      }
      updateHUD();
    });

  </script>
</body>
</html>
