<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Puzzle 4:3 – 2D ➜ 3D (magnétisme fiable + mélange)</title>
  <style>
    html,body{height:100%;margin:0;background:#0d1117;color:#e6edf3;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    #app{position:fixed;inset:0}
    .hud{
      position:fixed;left:12px;top:12px;z-index:5;display:flex;gap:8px;flex-wrap:wrap;align-items:center;
      background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px);
      font-size:13px;line-height:1.35
    }
    .btn{cursor:pointer;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.06);color:#e6edf3;padding:6px 10px;border-radius:8px;font-size:12px}
    .btn:hover{background:rgba(255,255,255,.12)}
    .badge{display:inline-block;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.1)}
    canvas{display:block;touch-action:none}
  </style>
  <script type="importmap">
    { "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    } }
  </script>
</head>
<body>
  <div id="app"></div>

  <div class="hud">
    <span class="badge" id="mode">Mode: 2D</span>
    <button id="startBtn" class="btn" title="Activer une 3D très limitée">Démarrer (3D)</button>
    <button id="faceBtn"  class="btn" title="Revenir face 2D (touche F)">Face</button>
    <button id="shuffleBtn" class="btn" title="Mélanger positions et orientations">Mélanger</button>
    <button id="resetBtn"   class="btn" title="Réinitialiser pièces à la grille">Réinitialiser</button>
    <span class="badge" id="infoBloc">Bloc: 1 pièce</span>
    <span class="badge" id="infoPlaced">0 placées</span>
  </div>

  <audio id="snapSound" src="click.wav" preload="auto"></audio>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ====== CONSTANTES PERSO =================================================
    const MODEL_URL = 'puzzle_50_scattered.glb';       // adapte si besoin
    const ROWS=5, COLS=10;
    const PUZZLE_W=3.0, PUZZLE_H=4.0;                  // 4:3 portrait
    const CELL_W=PUZZLE_W/COLS, CELL_H=PUZZLE_H/ROWS;

    // Zones et bornes d’affichage (tout doit rester visible)
    const BOUNDS_MARGIN = 0.75;                         // marge autour du puzzle pour mélanger
    const MIX_AREA_W = PUZZLE_W + 2*BOUNDS_MARGIN;
    const MIX_AREA_H = PUZZLE_H + 2*BOUNDS_MARGIN;

    // Magnétisme (sélectif + robuste)
    const SNAP_NEIGH_EAGER = 0.10;  // snap immédiat bloc↔bloc si très proche
    const SNAP_NEIGH       = 0.18;  // tolérance bloc↔bloc
    const SNAP_GRID        = 0.20;  // tolérance sur la position cible
    const POS_EPS          = 0.0025;
    const LERP_DRAG        = 0.65;
    const LERP_SNAP        = 0.60;

    // Collision (cercles englobants)
    const COLLISION_PAD = 0.98;     // 1 = tangence; <1 autorise léger recouvrement
    const MAX_SEP_STEP  = 0.06;
    const MIN_BLOCK_RADIUS = Math.min(CELL_W, CELL_H)*0.35;

    // Profondeur (2D stricte au départ; 3D limitée ensuite)
    const Z_LIMIT_2D = 0.0;
    const Z_LIMIT_3D = 0.02;
    const CAMERA_TILT_DEG = 6;

    // ====== SCÈNE & CAMÉRAS =================================================
    const app = document.getElementById('app');
    const scene = new THREE.Scene(); scene.background = new THREE.Color('#0d1117');

    let is3D = false;

    // Caméra ORTHO (2D – garantit face-on et échelle exacte)
    function makeOrtho(){
      const aspect = window.innerWidth / window.innerHeight;
      const viewH = (PUZZLE_H + 2*BOUNDS_MARGIN) * 1.05; // petite marge supplémentaire
      const viewW = viewH * aspect;
      const cam = new THREE.OrthographicCamera(-viewW/2, viewW/2, viewH/2, -viewH/2, -10, 10);
      cam.position.set(0,0,5); cam.lookAt(0,0,0);
      return cam;
    }
    const ortho = makeOrtho();

    // Caméra PERSPECTIVE (3D légère)
    const persp = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.01, 20);
    persp.position.set(0,0,6);

    let camera = ortho;

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    scene.add(new THREE.HemisphereLight(0xffffff,0x223344,0.85));
    const dl = new THREE.DirectionalLight(0xffffff,0.6); dl.position.set(2,3,4); scene.add(dl);

    // Contrôles 3D limités
    const controls = new OrbitControls(persp, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.08;
    controls.enableRotate = false; controls.enablePan = true; controls.enableZoom = true;
    controls.minDistance = 4.5; controls.maxDistance = 8.0;
    const tilt = THREE.MathUtils.degToRad(CAMERA_TILT_DEG);
    controls.minPolarAngle = Math.PI/2 - tilt;
    controls.maxPolarAngle = Math.PI/2 + tilt;

    // ====== RAYCAST / OUTILS =================================================
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    function setPointer(e){
      const p = e.touches?.[0] || e.changedTouches?.[0] || e;
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x=((p.clientX-rect.left)/rect.width)*2-1;
      pointer.y=-((p.clientY-rect.top)/rect.height)*2+1;
      return p;
    }

    // ====== STRUCTURES DE DONNÉES ===========================================
    const puzzleRoot = new THREE.Group(); scene.add(puzzleRoot);
    const pickableMeshes = [];
    const entries = [];            // {group, mesh, rc:{r,c}, target:Vector3, placed:boolean}
    const entryByKey = new Map();  // "rX_cY" -> entry

    const x0 = -PUZZLE_W/2 + CELL_W/2;
    const y0 =  PUZZLE_H/2 - CELL_H/2;
    const targetOf = (rc)=> new THREE.Vector3(x0 + rc.c*CELL_W, y0 - rc.r*CELL_H, 0);

    // ====== CHARGEMENT GLB ===================================================
    const loader = new GLTFLoader();
    loader.load(MODEL_URL, (gltf)=>{
      const root = gltf.scene;
      root.traverse(o=>{
        if(o.isMesh){
          pickableMeshes.push(o);
          const mats = Array.isArray(o.material)? o.material : [o.material];
          for(const m of mats){ if(m){ m.side = THREE.FrontSide; } }
        }
      });

      // Identifie chaque pièce (racines directes sous root)
      const roots = uniquePieceRoots(root);
      for(const piece of roots){
        const rc = parseRC(piece.name) || {r:0,c:0};
        const block = wrapAsBlock(piece, puzzleRoot);
        const entry = { group:block, mesh:piece, rc, target:targetOf(rc), placed:false };
        entries.push(entry);
        entryByKey.set(keyOf(rc), entry);
      }

      // 2D stricte et mélange initial (positions + orientations)
      planarZ(puzzleRoot, 0);
      shuffleAllPieces(true);
      frame2D();
      updateHUD();
    }, undefined, err=>console.error('GLB error:', err));

    function uniquePieceRoots(root){
      const set = new Set();
      root.traverse(o=>{
        if(o.isMesh){
          let n=o;
          while(n.parent && n.parent!==root) n=n.parent;
          set.add(n);
        }
      });
      return [...set];
    }

    function parseRC(name=''){ const m=/r(\d+)_c(\d+)/i.exec(name); return m?{r:+m[1],c:+m[2]}:null; }
    function keyOf(rc){ return `r${rc.r}_c${rc.c}`; }

    function wrapAsBlock(node, parent){
      const block = new THREE.Group(); parent.add(block);
      node.updateMatrixWorld(true);
      const wp = new THREE.Vector3(); node.getWorldPosition(wp);
      const wq = new THREE.Quaternion(); node.getWorldQuaternion(wq);
      block.position.copy(wp); block.quaternion.copy(wq); block.scale.set(1,1,1);
      block.add(node);
      node.position.set(0,0,0); node.quaternion.identity(); node.scale.set(1,1,1);
      return block;
    }

    // ====== UTILITAIRES BLOCS ===============================================
    function findBlock(g){ let n=g; while(n.parent && n.parent!==puzzleRoot) n=n.parent; return n||g; }
    function blockMembers(block){ const r=findBlock(block); return entries.filter(e=>findBlock(e.group)===r); }
    function blockBBox(block){ return new THREE.Box3().setFromObject(block); }
    function blockRadius(block){
      const size = blockBBox(block).getSize(new THREE.Vector3());
      const rx = Math.max(size.x*0.5, MIN_BLOCK_RADIUS);
      const ry = Math.max(size.y*0.5, MIN_BLOCK_RADIUS);
      return Math.sqrt(rx*rx + ry*ry);
    }
    function clampZ(limit, z){ return Math.max(-limit, Math.min(limit, z)); }
    function planarZ(root, z=0){ root.traverse(o=>{ if(o.position) o.position.z = z; }); }

    function clampInMixArea(v){
      const halfW = MIX_AREA_W/2, halfH = MIX_AREA_H/2;
      v.x = Math.max(-halfW, Math.min(halfW, v.x));
      v.y = Math.max(-halfH, Math.min(halfH, v.y));
    }

    // ====== MÉLANGE / RÉINITIALISATION ======================================
    function shuffleAllPieces(avoidOverlaps=false){
      // Disperse chaque bloc dans l’aire de mélange + orientation 0/90/180/270
      const angles = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
      for(const e of entries){
        const b = findBlock(e.group);
        if(blockMembers(b).length>1){
          // si déjà fusionné, on éclate le bloc en pièces unitaires pour un mélange “vrai”
          splitBlockToSingles(b);
        }
      }
      for(const e of entries){
        const g = e.group;
        const rx = (Math.random()-0.5)*MIX_AREA_W;
        const ry = (Math.random()-0.5)*MIX_AREA_H;
        g.position.set(rx, ry, 0);
        g.rotation.set(0,0, angles[Math.floor(Math.random()*angles.length)]);
      }
      planarZ(puzzleRoot, 0);
      if(avoidOverlaps) separateOverlapsOnce(0.12, 15); // 15 passes rapides pour dégrossir
      updateHUD();
    }

    function splitBlockToSingles(block){
      const members = blockMembers(block);
      if(members.length<=1) return;
      // on recrée un group racine par pièce (préserve la pose monde)
      for(const e of members){
        const single = new THREE.Group(); puzzleRoot.add(single);
        const wp = new THREE.Vector3(); e.group.getWorldPosition(wp);
        const wq = new THREE.Quaternion(); e.group.getWorldQuaternion(wq);
        single.position.copy(wp); single.quaternion.copy(wq); single.scale.set(1,1,1);
        // replacer le mesh racine associé à e dans single
        let node = e.mesh;
        let top = node; while(top.parent && top.parent!==e.group) top = top.parent;
        single.add(top);
        top.position.set(0,0,0); top.quaternion.identity(); top.scale.set(1,1,1);
        e.group = single; e.placed = false;
      }
      // supprimer l’ancien bloc
      puzzleRoot.remove(block);
    }

    function resetToGrid(){
      for(const e of entries){
        const b = findBlock(e.group);
        if(blockMembers(b).length>1) splitBlockToSingles(b);
      }
      for(const e of entries){
        const b = e.group;
        b.position.copy(e.target);
        b.rotation.set(0,0,0);
        e.placed = true;
      }
      planarZ(puzzleRoot, 0);
      updateHUD();
    }

    function separateOverlapsOnce(padScale=0.1, passes=8){
      // petites passes pour desserrer des chevauchements grossiers au démarrage
      for(let k=0;k<passes;k++){
        for(const ea of entries){
          const A = findBlock(ea.group);
          const cA = blockBBox(A).getCenter(new THREE.Vector3());
          const rA = blockRadius(A);
          for(const eb of entries){
            const B = findBlock(eb.group);
            if(B===A) continue;
            const cB = blockBBox(B).getCenter(new THREE.Vector3());
            const rB = blockRadius(B);
            const minD = (rA + rB) * (COLLISION_PAD - padScale);
            const delta = new THREE.Vector3().subVectors(cA, cB);
            const d = delta.length();
            if(d < minD && d > 1e-5){
              const need = (minD - d) * 0.5;
              delta.normalize().multiplyScalar(Math.min(need, MAX_SEP_STEP));
              A.position.add(delta); B.position.add(delta.multiplyScalar(-1));
              clampInMixArea(A.position); clampInMixArea(B.position);
              A.position.z = 0; B.position.z = 0;
            }
          }
        }
      }
    }

    // ====== NEIGHBORS & SNAP (bloc↔bloc robuste) ============================
    function neighRCs(rc){
      const list=[];
      if(rc.r>0)      list.push({r:rc.r-1,c:rc.c, dx:0,        dy:+CELL_H});
      if(rc.r<ROWS-1) list.push({r:rc.r+1,c:rc.c, dx:0,        dy:-CELL_H});
      if(rc.c>0)      list.push({r:rc.r,  c:rc.c-1, dx:-CELL_W,dy:0});
      if(rc.c<COLS-1) list.push({r:rc.r,  c:rc.c+1, dx:+CELL_W,dy:0});
      return list;
    }

    function bestNeighborPairFor(blockA){
      // cherche across TOUTES les pièces du bloc A, le meilleur voisin logique dans les autres blocs
      const memA = blockMembers(blockA);
      let best=null;
      for(const eA of memA){
        const posA = blockA.position; // centre du bloc
        for(const n of neighRCs(eA.rc)){
          const eB = entryByKey.get(keyOf({r:n.r,c:n.c})); if(!eB) continue;
          const blockB = findBlock(eB.group); if(blockB===blockA) continue;

          const posB = blockB.position;
          const desired = new THREE.Vector3(n.dx, n.dy, 0);      // posB - posA attendu
          const current = new THREE.Vector3().subVectors(posB, posA);
          const dist = current.sub(desired).length();
          if(best===null || dist < best.dist){
            best = {entryA:eA, entryB:eB, blockB, desired, dist, posB};
          }
        }
      }
      return best;
    }

    const snd = document.getElementById('snapSound');
    function playSnap(){ try{ snd.currentTime=0; snd.play().catch(()=>{});}catch{} }

    function snapBlockToPair(blockA, pair, final){
      const newPos = new THREE.Vector3().subVectors(pair.posB, pair.desired);
      if(final || pair.dist < SNAP_NEIGH_EAGER) blockA.position.copy(newPos);
      else blockA.position.lerp(newPos, LERP_SNAP);
      blockA.position.z = is3D ? clampZ(Z_LIMIT_3D, 0) : 0;

      const ok = blockA.position.distanceTo(newPos) < (final? 2*POS_EPS : 0.02);
      if(ok){
        blockA.position.copy(newPos); blockA.position.z = 0;
        mergeBlocks(blockA, pair.blockB);
        planarZ(findBlock(blockA), 0);
        playSnap(); updateHUD();
        return true;
      }
      return false;
    }

    function trySnapNeighborsBlock(block, final){
      const pair = bestNeighborPairFor(block);
      if(!pair) return false;
      const within = final ? (pair.dist <= 2*POS_EPS) : (pair.dist <= SNAP_NEIGH);
      if(!within) return false;
      return snapBlockToPair(block, pair, final);
    }

    function trySnapGrid(entry, final){
      const block = findBlock(entry.group);
      const d = block.position.distanceTo(entry.target);
      if(!final && d>SNAP_GRID) return false;

      const aim = entry.target.clone();
      if(final || d < SNAP_NEIGH_EAGER) block.position.copy(aim);
      else block.position.lerp(aim, LERP_SNAP);
      block.position.z = is3D ? clampZ(Z_LIMIT_3D, 0) : 0;

      const ok = block.position.distanceTo(aim) < (final? 2*POS_EPS : 0.02);
      if(ok){
        block.position.copy(aim); block.position.z = 0;
        entry.placed = true;
        planarZ(block, 0);
        playSnap(); updateHUD();
        return true;
      }
      return false;
    }

    // Fusion solide
    function mergeBlocks(A, B){
      A=findBlock(A); B=findBlock(B);
      if(A===B) return;
      const parent = new THREE.Group(); puzzleRoot.add(parent);

      // position du parent = barycentre simple des bbox centres
      const ca = blockBBox(A).getCenter(new THREE.Vector3());
      const cb = blockBBox(B).getCenter(new THREE.Vector3());
      parent.position.copy(ca.add(cb).multiplyScalar(0.5));

      reparentKeepWorld(A, parent);
      reparentKeepWorld(B, parent);
      planarZ(parent, 0);

      for(const e of entries){
        const r = findBlock(e.group);
        if(r===A || r===B || r===parent){ e.group = parent; }
      }
    }

    function reparentKeepWorld(child, newParent){
      const wp = new THREE.Vector3(); child.getWorldPosition(wp);
      const wq = new THREE.Quaternion(); child.getWorldQuaternion(wq);
      newParent.add(child);
      child.position.copy(newParent.worldToLocal(wp));
      const inv = newParent.getWorldQuaternion(new THREE.Quaternion()).invert();
      child.quaternion.copy(inv.multiply(wq));
      child.scale.set(1,1,1);
    }

    // ====== DRAG ROBUSTE + ANTI-CHEVAUCHEMENT DOUX ==========================
    let dragging = null;
    const dragPlane = new THREE.Plane(new THREE.Vector3(0,0,1), 0); // z=0

    function intersectPickable(){
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(pickableMeshes, true);
      for(const h of hits){
        const e = entryFromObject(h.object);
        if(e) return e;
      }
      return null;
    }
    function entryFromObject(obj){
      let n=obj; while(n && n.parent && n.parent!==puzzleRoot) n=n.parent;
      if(!n) return null;
      return entries.find(e=>e.group===n) || null;
    }

    function pointerDown(e){
      e.preventDefault();
      setPointer(e);
      const ePick = intersectPickable();
      if(!ePick) return;
      dragging = ePick;
      controls.enabled = false;
    }

    function pointerMove(e){
      if(!dragging) return;
      e.preventDefault();
      setPointer(e);

      raycaster.setFromCamera(pointer, camera);
      const hit = new THREE.Vector3();
      if(!raycaster.ray.intersectPlane(dragPlane, hit)) return;

      const block = findBlock(dragging.group);

      // 1) Déplacement doux vers le pointeur (toujours coplanaire)
      block.position.lerp(hit, LERP_DRAG);
      clampInMixArea(block.position);
      block.position.z = is3D ? clampZ(Z_LIMIT_3D, 0) : 0;

      // 2) Snap bloc↔bloc prioritaire (meilleure paire adjacente)
      if(trySnapNeighborsBlock(block, false)) return;

      // 3) Snap grille (position cible) – utile pour poser un bloc complet
      if(trySnapGrid(dragging, false)) return;

      // 4) Séparation douce des chevauchements résiduels (une seule passe)
      resolveCollisionsOnce(block);
    }

    function pointerUp(e){
      if(!dragging) return;
      e.preventDefault();

      const block = findBlock(dragging.group);
      if(!trySnapNeighborsBlock(block, true)) trySnapGrid(dragging, true);
      resolveCollisionsOnce(block);

      dragging = null;
      controls.enabled = is3D;
    }

    function resolveCollisionsOnce(block){
      const A = findBlock(block);
      const cA = blockBBox(A).getCenter(new THREE.Vector3());
      const rA = blockRadius(A);
      for(const e of entries){
        const B = findBlock(e.group);
        if(B===A) continue;
        const cB = blockBBox(B).getCenter(new THREE.Vector3());
        const rB = blockRadius(B);
        const minD = (rA + rB) * COLLISION_PAD;
        const delta = new THREE.Vector3().subVectors(cA, cB);
        const d = delta.length();
        if(d < minD && d > 1e-5){
          const overlap = (minD - d);
          const step = Math.min(overlap, MAX_SEP_STEP);
          delta.normalize().multiplyScalar(step);
          A.position.add(delta);
          clampInMixArea(A.position);
          A.position.z = is3D ? clampZ(Z_LIMIT_3D, 0) : 0;
          cA.add(delta); // mise à jour locale pour la passe courante
        }
      }
    }

    // ====== HUD / CAMS / RENDER =============================================
    const infoPlaced = document.getElementById('infoPlaced');
    const infoBloc   = document.getElementById('infoBloc');
    const modeInfo   = document.getElementById('mode');

    function updateHUD(){
      const nPlaced = entries.filter(e=>e.placed).length;
      infoPlaced.textContent = `${nPlaced} placées`;
      const blk = dragging ? findBlock(dragging.group) : null;
      const n = blk ? blockMembers(blk).length : 1;
      infoBloc.textContent = `Bloc: ${n} pièce${n>1?'s':''}`;
    }

    function frame2D(){ camera = ortho; modeInfo.textContent='Mode: 2D'; planarZ(puzzleRoot, 0); }
    function frame3D(){
      camera = persp; modeInfo.textContent='Mode: 3D (limitée)';
      puzzleRoot.rotation.set(THREE.MathUtils.degToRad(4), THREE.MathUtils.degToRad(-3), 0);
      controls.update();
    }

    function render(){ requestAnimationFrame(render); if(is3D) controls.update(); updateHUD(); renderer.render(scene, camera); }
    render();

    window.addEventListener('resize', ()=>{
      const aspect = window.innerWidth / window.innerHeight;
      const viewH = (PUZZLE_H + 2*BOUNDS_MARGIN) * 1.05;
      const viewW = viewH * aspect;
      ortho.left=-viewW/2; ortho.right=viewW/2; ortho.top=viewH/2; ortho.bottom=-viewH/2; ortho.updateProjectionMatrix();
      persp.aspect = aspect; persp.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='f'){ is3D=false; controls.enableRotate=false; frame2D(); } });

    // ====== BOUTONS ==========================================================
    document.getElementById('startBtn').addEventListener('click', ()=>{ is3D=true; controls.enableRotate=true; controls.enabled=true; frame3D(); });
    document.getElementById('faceBtn').addEventListener('click',  ()=>{ is3D=false; controls.enableRotate=false; frame2D(); });
    document.getElementById('shuffleBtn').addEventListener('click', ()=>{ is3D=false; controls.enableRotate=false; frame2D(); shuffleAllPieces(true); });
    document.getElementById('resetBtn').addEventListener('click',   ()=>{ is3D=false; controls.enableRotate=false; frame2D(); resetToGrid(); });
  </script>
</body>
</html>
