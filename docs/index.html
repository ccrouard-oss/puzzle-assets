<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Puzzle 3D – Protect the Oceans</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0d1117; color:#e6edf3; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #app { position: fixed; inset: 0; }
    .hud {
      position: fixed; left: 12px; top: 12px; z-index: 5;
      background: rgba(0,0,0,.45); border: 1px solid rgba(255,255,255,.08);
      padding: 8px 10px; border-radius: 10px; backdrop-filter: blur(6px);
      font-size: 13px; line-height: 1.35;
    }
    .hud b { color:#fff; }
    .badge { display:inline-block; padding:2px 6px; border-radius: 6px; border:1px solid rgba(255,255,255,.1); }
    canvas { display:block; }
  </style>

  <!-- Import map Three.js r160 -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <div><b>Puzzle 3D</b> – Protect the Oceans</div>
    <div class="badge" id="placedInfo">0 / 50 placées</div>
  </div>

  <!-- Son de "clic" à la pose (facultatif : ajoutez click.wav dans le même dossier) -->
  <audio id="snapSound" src="click.wav" preload="auto"></audio>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ---------------------- CONFIG PROJET ----------------------
    const MODEL_URL = 'puzzle_50_scattered.glb'; // même dossier que cette page
    // Dimensions de l'image assemblée (doivent correspondre à Blender)
    const ROWS = 5, COLS = 10;
    const PUZZLE_W = 3.0, PUZZLE_H = 4.0;
    const CELL_W = PUZZLE_W / COLS;
    const CELL_H = PUZZLE_H / ROWS;

    // Magnétisme & snap
    const CAPTURE_RADIUS = 0.18;     // portée d'accroche (monde, en mètres)
    const SNAP_EPS_POS   = 0.002;    // tol. finale position
    const SNAP_EPS_ROT   = 0.001;    // tol. finale rotation (radians approx via quat)
    const LERP_ALPHA_DRAG = 0.6;     // fluidité du drag
    const LERP_ALPHA_SNAP = 0.35;    // vitesse aimantation

    // Caméra / vue de face
    const FRONT_PADDING = 0.6;       // marge de cadrage (0.0–1.0)
    const LOCK_FACE_VIEW = true;     // limite l'orbite à une vue quasi de face

    // Verrouiller les pièces posées ?
    const LOCK_PLACED = true;

    // ---------------------- SCÈNE DE BASE ----------------------
    const app = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#0d1117');

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 100);
    camera.position.set(0, 0, 6);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    // Légère lumière douce
    const hemi = new THREE.HemisphereLight(0xffffff, 0x334466, 0.7);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(2, 3, 4);
    scene.add(dir);

    // Sol invisible pour référence (plan Z=0)
    const dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // z=0

    // Contrôles orbitaux
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    if (LOCK_FACE_VIEW) {
      controls.minPolarAngle = Math.PI / 2 - 0.03;
      controls.maxPolarAngle = Math.PI / 2 + 0.03;
      controls.minAzimuthAngle = -0.03;
      controls.maxAzimuthAngle =  0.03;
    }

    // ---------------------- OUTILS ----------------------
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    const tmpV3 = new THREE.Vector3();

    function screenToWorldOnPlane(clientX, clientY, plane, outVec3) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(pointer, camera);
      const hit = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, hit);
      outVec3.copy(hit);
      return outVec3;
    }

    // ---------------------- CHARGEMENT MODÈLE ----------------------
    const loader = new GLTFLoader();
    const pieces = [];  // {mesh, target:{position, quaternion}}
    let puzzleRoot = null;

    loader.load(MODEL_URL, (gltf) => {
      puzzleRoot = gltf.scene;
      scene.add(puzzleRoot);

      // Collecte des pièces : stratégie 1 = enfants directs “mesh”, sinon tous les Mesh
      const topLevelMeshes = [];
      puzzleRoot.children.forEach(ch => { if (ch.isMesh || ch.isGroup) topLevelMeshes.push(ch); });

      const meshes = [];
      if (topLevelMeshes.length > 0) {
        // Si vos pièces sont des groupes contenant 1 mesh => on prend le groupe comme "pièce"
        topLevelMeshes.forEach(ch => {
          if (ch.isMesh) meshes.push(ch);
          else {
            // si group, prendre le group comme pièce "maître"
            meshes.push(ch);
          }
        });
      } else {
        // fallback : traverse
        puzzleRoot.traverse(obj => { if (obj.isMesh) meshes.push(obj); });
      }

      // Déterminer les "cibles" (position/rotation) pour chaque pièce
      meshes.forEach(m => {
        const target = computeTargetTransform(m);
        pieces.push({ mesh: m, target, placed: false });
      });

      // Cadrage initial de face
      const bbox = computePuzzleBBox(pieces.map(p => p.mesh));
      frameFrontView(bbox);

      // Mise à niveau Z=0 et normalisation des rotations cibles
      pieces.forEach(p => {
        p.target.position.z = 0;
        if (!p.mesh.quaternion) p.mesh.quaternion = new THREE.Quaternion();
      });

      // UI compteur
      updatePlacedCounter();
    }, undefined, (err) => {
      console.error('Erreur chargement GLB:', err);
    });

    // Cible à partir de userData.home OU du nom "piece_rX_cY" OU grille centrée
    function parseRowColFromName(name) {
      const m = /r(\d+)_c(\d+)/i.exec(name);
      return m ? { r: parseInt(m[1], 10), c: parseInt(m[2], 10) } : null;
    }

    function computeTargetTransform(obj) {
      // A) userData.home présent ?
      if (obj.userData && obj.userData.home) {
        const { pos, quat } = obj.userData.home;
        return {
          position: new THREE.Vector3(pos.x, pos.y, pos.z),
          quaternion: new THREE.Quaternion(quat.x, quat.y, quat.z, quat.w),
        };
      }
      // B) Nom encodé
      const rc = parseRowColFromName(obj.name || '');
      if (rc) {
        const x0 = -PUZZLE_W / 2 + CELL_W / 2;
        const y0 =  PUZZLE_H / 2 - CELL_H / 2;
        const x = x0 + rc.c * CELL_W;
        const y = y0 - rc.r * CELL_H;
        return {
          position: new THREE.Vector3(x, y, 0),
          quaternion: new THREE.Quaternion(), // face-up
        };
      }
      // C) Fallback : grille approximative en se basant sur l'ordre
      // (répartition ligne/colonne depuis l'index arbitraire)
      const idx = (fallbackIndexCounter++ % (ROWS * COLS));
      const r = Math.floor(idx / COLS), c = idx % COLS;
      const x0 = -PUZZLE_W / 2 + CELL_W / 2;
      const y0 =  PUZZLE_H / 2 - CELL_H / 2;
      const x = x0 + c * CELL_W;
      const y = y0 - r * CELL_H;
      return { position: new THREE.Vector3(x, y, 0), quaternion: new THREE.Quaternion() };
    }
    let fallbackIndexCounter = 0;

    function computePuzzleBBox(meshes) {
      const bbox = new THREE.Box3();
      meshes.forEach(m => bbox.expandByObject(m));
      return bbox;
    }

    function frameFrontView(bbox) {
      const center = bbox.getCenter(new THREE.Vector3());
      const size = bbox.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y);
      const fov = THREE.MathUtils.degToRad(camera.fov);
      const dist = (maxDim * (1 + FRONT_PADDING)) / (2 * Math.tan(fov / 2));
      camera.position.set(0, 0, dist);
      camera.up.set(0, 1, 0);
      camera.lookAt(center);
      controls.target.copy(center);
      controls.update();
    }

    // ---------------------- DRAG & MAGNÉTISME ----------------------
    const placedInfo = document.getElementById('placedInfo');
    const audioEl = document.getElementById('snapSound');

    let dragging = null;
    let dragOffset = new THREE.Vector3();

    function pointerDown(ev) {
      const { clientX, clientY } = getPrimaryPoint(ev);
      setPointerFromClient(clientX, clientY);
      raycaster.setFromCamera(pointer, camera);

      // Intersections sur les pièces non verrouillées
      const intersects = raycaster.intersectObjects(
        pieces.map(p => p.mesh),
        true
      ).filter(hit => {
        const piece = findPieceRoot(hit.object);
        return piece && !(piece.userData && piece.userData.locked);
      });

      if (intersects.length > 0) {
        const rootMesh = findPieceRoot(intersects[0].object);
        dragging = pieces.find(p => p.mesh === rootMesh);
        if (dragging) {
          // calcule l'offset entre position pièce et point sous curseur (sur z=0)
          const world = screenToWorldOnPlane(clientX, clientY, dragPlane, tmpV3);
          dragOffset.copy(dragging.mesh.position).sub(world);
        }
      }
    }

    function pointerMove(ev) {
      if (!dragging) return;
      const { clientX, clientY } = getPrimaryPoint(ev);
      const world = screenToWorldOnPlane(clientX, clientY, dragPlane, tmpV3);
      world.add(dragOffset);

      // Drag fluide
      dragging.mesh.position.lerp(world, LERP_ALPHA_DRAG);

      // Aimantation continue pendant le drag
      tryMagnet(dragging);
    }

    function pointerUp() {
      if (dragging) {
        // Dernière tentative de snap
        tryMagnet(dragging, true);
        dragging = null;
      }
    }

    function getPrimaryPoint(ev) {
      return ev.touches && ev.touches.length ? ev.touches[0] : ev.changedTouches && ev.changedTouches.length ? ev.changedTouches[0] : ev;
    }

    function setPointerFromClient(clientX, clientY) {
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;
    }

    function findPieceRoot(obj) {
      // Si vos pièces sont des groupes, remontez jusqu'au parent direct inclus dans "pieces"
      let cur = obj;
      while (cur && !pieces.some(p => p.mesh === cur)) cur = cur.parent;
      return cur;
    }

    function angleBetweenQuats(a, b) {
      const dot = Math.abs(a.dot(b));
      return Math.acos(Math.min(1, Math.max(-1, 2 * dot * dot - 1)));
    }

    function tryMagnet(entry, finalAttempt = false) {
      const mesh = entry.mesh;
      const tgt = entry.target;

      if (entry.placed) return;
      const dPos = mesh.position.distanceTo(tgt.position);
      if (dPos > CAPTURE_RADIUS) return;

      // Aimantation douce vers la cible
      mesh.position.lerp(tgt.position, LERP_ALPHA_SNAP);

      const a = angleBetweenQuats(mesh.quaternion, tgt.quaternion);
      if (a > SNAP_EPS_ROT) {
        mesh.quaternion.slerp(tgt.quaternion, LERP_ALPHA_SNAP);
      }

      // Snap dur si suffisamment proche (ou si dernier essai lors du drop)
      const closeEnough = dPos < SNAP_EPS_POS && a < SNAP_EPS_ROT;
      if (closeEnough || finalAttempt) {
        // Teste à nouveau après la slerp/lerp
        if (mesh.position.distanceTo(tgt.position) < 2*SNAP_EPS_POS && angleBetweenQuats(mesh.quaternion, tgt.quaternion) < 2*SNAP_EPS_ROT) {
          mesh.position.copy(tgt.position);
          mesh.quaternion.copy(tgt.quaternion);
          mesh.position.set(
            Math.round(mesh.position.x * 1000) / 1000,
            Math.round(mesh.position.y * 1000) / 1000,
            Math.round(mesh.position.z * 1000) / 1000
          );
          entry.placed = true;
          if (LOCK_PLACED) mesh.userData.locked = true;
          playSnap();
          updatePlacedCounter();
        }
      }
    }

    function playSnap() {
      if (!audioEl) return;
      try {
        audioEl.currentTime = 0;
        audioEl.play().catch(()=>{ /* silencieux si bloqué par le navigateur */ });
      } catch {}
    }

    function updatePlacedCounter() {
      const count = pieces.filter(p => p.placed).length;
      placedInfo.textContent = `${count} / ${pieces.length || (ROWS*COLS)} placées`;
    }

    // ---------------------- BOUCLE RENDER ----------------------
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ---------------------- EVENTS ----------------------
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    renderer.domElement.addEventListener('pointerdown', pointerDown, { passive: false });
    window.addEventListener('pointermove', pointerMove, { passive: false });
    window.addEventListener('pointerup', pointerUp, { passive: false });

    // Mobile
    renderer.domElement.addEventListener('touchstart', pointerDown, { passive: false });
    window.addEventListener('touchmove', pointerMove, { passive: false });
    window.addEventListener('touchend', pointerUp, { passive: false });
  </script>
</body>
</html>
